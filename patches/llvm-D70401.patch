diff --git a/clang/lib/Basic/Targets/RISCV.cpp b/clang/lib/Basic/Targets/RISCV.cpp
index 7c801657b6ac..311238fb5ac1 100644
--- a/clang/lib/Basic/Targets/RISCV.cpp
+++ b/clang/lib/Basic/Targets/RISCV.cpp
@@ -149,7 +149,7 @@ void RISCVTargetInfo::getTargetDefines(const LangOptions &Opts,
   else
     Builder.defineMacro("__riscv_float_abi_soft");
 
-  if (ABIName == "ilp32e")
+  if (ABIName == "ilp32e" || ABIName == "lp64e")
     Builder.defineMacro("__riscv_abi_rve");
 
   Builder.defineMacro("__riscv_arch_test");
@@ -200,6 +200,13 @@ void RISCVTargetInfo::getTargetDefines(const LangOptions &Opts,
     // Currently we support the v0.11 RISC-V V intrinsics.
     Builder.defineMacro("__riscv_v_intrinsic", Twine(getVersionValue(0, 11)));
   }
+
+  if (ISAInfo->hasExtension("e")) {
+    if (Is64Bit)
+      Builder.defineMacro("__riscv_64e");
+    else
+      Builder.defineMacro("__riscv_32e");
+  }
 }
 
 static constexpr Builtin::Info BuiltinInfo[] = {
@@ -315,6 +322,11 @@ bool RISCVTargetInfo::handleTargetFeatures(std::vector<std::string> &Features,
   if (ABI.empty())
     ABI = ISAInfo->computeDefaultABI().str();
 
+  if (ABI == "ilp32e" && ISAInfo->hasExtension("d")) {
+    Diags.Report(diag::err_invalid_feature_combination)
+        << "ILP32E must not be used with the D ISA extension";
+    return false;
+  }
   return true;
 }
 
diff --git a/clang/lib/Basic/Targets/RISCV.h b/clang/lib/Basic/Targets/RISCV.h
index adff1da4ad5e..bb36a1c20186 100644
--- a/clang/lib/Basic/Targets/RISCV.h
+++ b/clang/lib/Basic/Targets/RISCV.h
@@ -120,6 +120,12 @@ public:
   }
 
   bool setABI(const std::string &Name) override {
+    if (Name == "ilp32e") {
+      ABI = Name;
+      resetDataLayout("e-m:e-p:32:32-i64:64-n32-S32");
+      return true;
+    }
+
     if (Name == "ilp32" || Name == "ilp32f" || Name == "ilp32d") {
       ABI = Name;
       return true;
@@ -144,6 +150,12 @@ public:
   }
 
   bool setABI(const std::string &Name) override {
+    if (Name == "lp64e") {
+      ABI = Name;
+      resetDataLayout("e-m:e-p:64:64-i64:64-i128:128-n32:64-S64");
+      return true;
+    }
+
     if (Name == "lp64" || Name == "lp64f" || Name == "lp64d") {
       ABI = Name;
       return true;
diff --git a/clang/lib/CodeGen/TargetInfo.cpp b/clang/lib/CodeGen/TargetInfo.cpp
index 9e2d7a85d100..7124b0d90190 100644
--- a/clang/lib/CodeGen/TargetInfo.cpp
+++ b/clang/lib/CodeGen/TargetInfo.cpp
@@ -10984,8 +10984,9 @@ private:
   // ISA might have a wider FLen than the selected ABI (e.g. an RV32IF target
   // with soft float ABI has FLen==0).
   unsigned FLen;
-  static const int NumArgGPRs = 8;
-  static const int NumArgFPRs = 8;
+  const int NumArgGPRs;
+  const int NumArgFPRs;
+  const bool EABI;
   bool detectFPCCEligibleStructHelper(QualType Ty, CharUnits CurOff,
                                       llvm::Type *&Field1Ty,
                                       CharUnits &Field1Off,
@@ -10993,8 +10994,10 @@ private:
                                       CharUnits &Field2Off) const;
 
 public:
-  RISCVABIInfo(CodeGen::CodeGenTypes &CGT, unsigned XLen, unsigned FLen)
-      : DefaultABIInfo(CGT), XLen(XLen), FLen(FLen) {}
+  RISCVABIInfo(CodeGen::CodeGenTypes &CGT, unsigned XLen, unsigned FLen,
+               bool EABI)
+      : DefaultABIInfo(CGT), XLen(XLen), FLen(FLen), NumArgGPRs(EABI ? 6 : 8),
+        NumArgFPRs(FLen != 0 ? 8 : 0), EABI(EABI) {}
 
   // DefaultABIInfo's classifyReturnType and classifyArgumentType are
   // non-virtual, but computeInfo is virtual, so we overload it.
@@ -11043,7 +11046,7 @@ void RISCVABIInfo::computeInfo(CGFunctionInfo &FI) const {
   }
 
   int ArgGPRsLeft = IsRetIndirect ? NumArgGPRs - 1 : NumArgGPRs;
-  int ArgFPRsLeft = FLen ? NumArgFPRs : 0;
+  int ArgFPRsLeft = NumArgFPRs;
   int NumFixedArgs = FI.getNumRequiredArgs();
 
   int ArgNum = 0;
@@ -11322,9 +11325,12 @@ ABIArgInfo RISCVABIInfo::classifyArgumentType(QualType Ty, bool IsFixed,
   // Determine the number of GPRs needed to pass the current argument
   // according to the ABI. 2*XLen-aligned varargs are passed in "aligned"
   // register pairs, so may consume 3 registers.
+  // TODO: To be compatible with GCC's behaviors, we don't align registers
+  // currently if we are using ILP32E calling convention. This behavior may be
+  // changed when RV32E/ILP32E is ratified.
   int NeededArgGPRs = 1;
   if (!IsFixed && NeededAlign == 2 * XLen)
-    NeededArgGPRs = 2 + (ArgGPRsLeft % 2);
+    NeededArgGPRs = 2 + (EABI && XLen == 32 ? 0 : (ArgGPRsLeft % 2));
   else if (Size > XLen && Size <= 2 * XLen)
     NeededArgGPRs = 2;
 
@@ -11404,6 +11410,13 @@ Address RISCVABIInfo::EmitVAArg(CodeGenFunction &CGF, Address VAListAddr,
 
   auto TInfo = getContext().getTypeInfoInChars(Ty);
 
+  // TODO: To be compatible with GCC's behaviors, we force arguments with
+  // 2×XLEN-bit alignment and size at most 2×XLEN bits like `long long`,
+  // `unsigned long long` and `double` to have 4-bytes alignment. This
+  // behavior may be changed when RV32E/ILP32E is ratified.
+  if (EABI && XLen == 32)
+    TInfo.Align = std::min(TInfo.Align, CharUnits::fromQuantity(4));
+
   // Arguments bigger than 2*Xlen bytes are passed indirectly.
   bool IsIndirect = TInfo.Width > 2 * SlotSize;
 
@@ -11423,8 +11436,9 @@ namespace {
 class RISCVTargetCodeGenInfo : public TargetCodeGenInfo {
 public:
   RISCVTargetCodeGenInfo(CodeGen::CodeGenTypes &CGT, unsigned XLen,
-                         unsigned FLen)
-      : TargetCodeGenInfo(std::make_unique<RISCVABIInfo>(CGT, XLen, FLen)) {}
+                         unsigned FLen, bool EABI)
+      : TargetCodeGenInfo(
+            std::make_unique<RISCVABIInfo>(CGT, XLen, FLen, EABI)) {}
 
   void setTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
                            CodeGen::CodeGenModule &CGM) const override {
@@ -12330,7 +12344,8 @@ const TargetCodeGenInfo &CodeGenModule::getTargetCodeGenInfo() {
       ABIFLen = 32;
     else if (ABIStr.endswith("d"))
       ABIFLen = 64;
-    return SetCGInfo(new RISCVTargetCodeGenInfo(Types, XLen, ABIFLen));
+    bool EABI = ABIStr.endswith("e");
+    return SetCGInfo(new RISCVTargetCodeGenInfo(Types, XLen, ABIFLen, EABI));
   }
 
   case llvm::Triple::systemz: {
diff --git a/clang/lib/Driver/ToolChains/Arch/RISCV.cpp b/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
index 4c34c09d5589..dd58019dde91 100644
--- a/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
+++ b/clang/lib/Driver/ToolChains/Arch/RISCV.cpp
@@ -198,6 +198,7 @@ StringRef riscv::getRISCVABI(const ArgList &Args, const llvm::Triple &Triple) {
   // rv32e -> ilp32e
   // rv32* -> ilp32
   // rv64g | rv64*d -> lp64d
+  // rv64e -> lp64e
   // rv64* -> lp64
   StringRef Arch = getRISCVArch(Args, Triple);
 
@@ -275,6 +276,7 @@ StringRef riscv::getRISCVArch(const llvm::opt::ArgList &Args,
   // 3. Choose a default based on `-mabi=`
   //
   // ilp32e -> rv32e
+  // lp64e -> rv64e
   // ilp32 | ilp32f | ilp32d -> rv32imafdc
   // lp64 | lp64f | lp64d -> rv64imafdc
   if (const Arg *A = Args.getLastArg(options::OPT_mabi_EQ)) {
@@ -282,6 +284,8 @@ StringRef riscv::getRISCVArch(const llvm::opt::ArgList &Args,
 
     if (MABI.equals_insensitive("ilp32e"))
       return "rv32e";
+    else if (MABI.startswith_insensitive("lp64e"))
+      return "rv64e";
     else if (MABI.startswith_insensitive("ilp32"))
       return "rv32imafdc";
     else if (MABI.startswith_insensitive("lp64"))
diff --git a/clang/test/CodeGen/RISCV/riscv32-ilp32e-error.c b/clang/test/CodeGen/RISCV/riscv32-ilp32e-error.c
new file mode 100644
index 000000000000..86444112bde2
--- /dev/null
+++ b/clang/test/CodeGen/RISCV/riscv32-ilp32e-error.c
@@ -0,0 +1,4 @@
+// RUN: not %clang_cc1 -triple riscv32 -target-feature +d -emit-llvm -target-abi ilp32e %s 2>&1 \
+// RUN:     | FileCheck -check-prefix=ILP32E-WITH-FD %s
+
+// ILP32E-WITH-FD: error: invalid feature combination: ILP32E must not be used with the D ISA extension
diff --git a/clang/test/Preprocessor/riscv-target-features.c b/clang/test/Preprocessor/riscv-target-features.c
index 00cc896b82a8..8caa1e24213e 100644
--- a/clang/test/Preprocessor/riscv-target-features.c
+++ b/clang/test/Preprocessor/riscv-target-features.c
@@ -3,6 +3,7 @@
 // RUN: %clang -target riscv64-unknown-linux-gnu -march=rv64i -x c -E -dM %s \
 // RUN: -o - | FileCheck %s
 
+// CHECK-NOT: __riscv_32e
 // CHECK-NOT: __riscv_div
 // CHECK-NOT: __riscv_m
 // CHECK-NOT: __riscv_mul
@@ -48,6 +49,21 @@
 // CHECK-NOT: __riscv_zcf
 // CHECK-NOT: __riscv_h
 
+// RUN: %clang -target riscv32-unknown-linux-gnu -march=rv32e -x c -E -dM %s \
+// RUN: -o - | FileCheck --check-prefixes=CHECK-E-EXT,CHECK-RV32E %s
+// RUN: %clang -target riscv64-unknown-linux-gnu -march=rv64e -x c -E -dM %s \
+// RUN: -o - | FileCheck --check-prefixes=CHECK-E-EXT,CHECK-RV64E %s
+// RUN: %clang -target riscv32-unknown-linux-gnu -march=rv32i -mabi=ilp32e -x c -E -dM %s \
+// RUN: -o - | FileCheck --check-prefix=CHECK-ILP32E %s
+// RUN: %clang -target riscv64-unknown-linux-gnu -march=rv64i -mabi=lp64e -x c -E -dM %s \
+// RUN: -o - | FileCheck --check-prefix=CHECK-LP64E %s
+// CHECK-RV32E: __riscv_32e 1
+// CHECK-RV64E: __riscv_64e 1
+// CHECK-E-EXT: __riscv_abi_rve 1
+// CHECK-E-EXT: __riscv_e 2000000{{$}}
+// CHECK-ILP32E: __riscv_abi_rve 1
+// CHECK-LP64E: __riscv_abi_rve 1
+
 // RUN: %clang -target riscv32-unknown-linux-gnu -march=rv32im -x c -E -dM %s \
 // RUN: -o - | FileCheck --check-prefix=CHECK-M-EXT %s
 // RUN: %clang -target riscv64-unknown-linux-gnu -march=rv64im -x c -E -dM %s \
diff --git a/llvm/include/llvm/Support/RISCVAttributes.h b/llvm/include/llvm/Support/RISCVAttributes.h
index a8ce8f4d8daf..8643debb78eb 100644
--- a/llvm/include/llvm/Support/RISCVAttributes.h
+++ b/llvm/include/llvm/Support/RISCVAttributes.h
@@ -34,7 +34,7 @@ enum AttrType : unsigned {
   PRIV_SPEC_REVISION = 12,
 };
 
-enum StackAlign { ALIGN_4 = 4, ALIGN_16 = 16 };
+enum StackAlign { ALIGN_4 = 4, ALIGN_8 = 8, ALIGN_16 = 16 };
 
 enum { NOT_ALLOWED = 0, ALLOWED = 1 };
 
diff --git a/llvm/lib/Support/RISCVISAInfo.cpp b/llvm/lib/Support/RISCVISAInfo.cpp
index b14fe1358d1f..674d7e5e995f 100644
--- a/llvm/lib/Support/RISCVISAInfo.cpp
+++ b/llvm/lib/Support/RISCVISAInfo.cpp
@@ -854,7 +854,6 @@ Error RISCVISAInfo::checkDependency() {
 
   // Additional dependency checks.
   // TODO: The 'q' extension requires rv64.
-  // TODO: It is illegal to specify 'e' extensions with 'f' and 'd'.
 
   return Error::success();
 }
@@ -1083,12 +1082,14 @@ RISCVISAInfo::postProcessAndChecking(std::unique_ptr<RISCVISAInfo> &&ISAInfo) {
 
 StringRef RISCVISAInfo::computeDefaultABI() const {
   if (XLen == 32) {
-    if (hasExtension("d"))
-      return "ilp32d";
     if (hasExtension("e"))
       return "ilp32e";
+    if (hasExtension("d"))
+      return "ilp32d";
     return "ilp32";
   } else if (XLen == 64) {
+    if (hasExtension("e"))
+      return "lp64e";
     if (hasExtension("d"))
       return "lp64d";
     return "lp64";
diff --git a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
index 3292df6a966a..af59d1a9591d 100644
--- a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
+++ b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.cpp
@@ -61,6 +61,11 @@ ABI computeTargetABI(const Triple &TT, FeatureBitset FeatureBits,
     TargetABI = ABI_Unknown;
   }
 
+  if ((TargetABI == RISCVABI::ABI::ABI_ILP32E ||
+       (TargetABI == ABI_Unknown && IsRV32E && !IsRV64)) &&
+      FeatureBits[RISCV::FeatureStdExtD])
+    report_fatal_error("ILP32E must not be used with the D ISA extension");
+
   if (TargetABI != ABI_Unknown)
     return TargetABI;
 
diff --git a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
index 2cf2045c1719..308d7d1609fd 100644
--- a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
+++ b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVBaseInfo.h
@@ -385,6 +385,7 @@ enum ABI {
   ABI_LP64,
   ABI_LP64F,
   ABI_LP64D,
+  ABI_LP64E,
   ABI_Unknown
 };
 
diff --git a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
index 379aaa713a00..d5fa67909607 100644
--- a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
+++ b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVELFStreamer.cpp
@@ -173,6 +173,7 @@ void RISCVTargetELFStreamer::finish() {
     EFlags |= ELF::EF_RISCV_FLOAT_ABI_DOUBLE;
     break;
   case RISCVABI::ABI_ILP32E:
+  case RISCVABI::ABI_LP64E:
     EFlags |= ELF::EF_RISCV_RVE;
     break;
   case RISCVABI::ABI_Unknown:
diff --git a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
index 756cc14a8701..62127a3422ea 100644
--- a/llvm/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
+++ b/llvm/lib/Target/RISCV/MCTargetDesc/RISCVTargetStreamer.cpp
@@ -48,7 +48,9 @@ void RISCVTargetStreamer::setTargetABI(RISCVABI::ABI ABI) {
 
 void RISCVTargetStreamer::emitTargetAttributes(const MCSubtargetInfo &STI) {
   if (STI.hasFeature(RISCV::FeatureRV32E))
-    emitAttribute(RISCVAttrs::STACK_ALIGN, RISCVAttrs::ALIGN_4);
+    emitAttribute(RISCVAttrs::STACK_ALIGN, STI.hasFeature(RISCV::Feature32Bit)
+                                               ? RISCVAttrs::ALIGN_4
+                                               : RISCVAttrs::ALIGN_8);
   else
     emitAttribute(RISCVAttrs::STACK_ALIGN, RISCVAttrs::ALIGN_16);
 
diff --git a/llvm/lib/Target/RISCV/RISCVCallingConv.td b/llvm/lib/Target/RISCV/RISCVCallingConv.td
index 025454f8fcca..1af04b6eba74 100644
--- a/llvm/lib/Target/RISCV/RISCVCallingConv.td
+++ b/llvm/lib/Target/RISCV/RISCVCallingConv.td
@@ -13,8 +13,10 @@
 // The RISC-V calling convention is handled with custom code in
 // RISCVISelLowering.cpp (CC_RISCV).
 
+def CSR_ILP32E_LP64E : CalleeSavedRegs<(add X1, X3, X4, X8, X9)>;
+
 def CSR_ILP32_LP64
-    : CalleeSavedRegs<(add X1, X3, X4, X8, X9, (sequence "X%u", 18, 27))>;
+    : CalleeSavedRegs<(add CSR_ILP32E_LP64E, (sequence "X%u", 18, 27))>;
 
 def CSR_ILP32F_LP64F
     : CalleeSavedRegs<(add CSR_ILP32_LP64,
diff --git a/llvm/lib/Target/RISCV/RISCVFeatures.td b/llvm/lib/Target/RISCV/RISCVFeatures.td
index be8834fd4c2f..427da6567371 100644
--- a/llvm/lib/Target/RISCV/RISCVFeatures.td
+++ b/llvm/lib/Target/RISCV/RISCVFeatures.td
@@ -10,6 +10,13 @@
 // RISC-V subtarget features and instruction predicates.
 //===----------------------------------------------------------------------===//
 
+def FeatureStdExtI
+    : SubtargetFeature<"i", "HasStdExtI", "true",
+                       "'I' (Base Integer Instruction Set)">;
+def HasStdExtI : Predicate<"Subtarget->hasStdExtI()">,
+                           AssemblerPredicate<(all_of FeatureStdExtI),
+                           "'I' (Base Integer Instruction Set)">;
+
 def FeatureStdExtM
     : SubtargetFeature<"m", "HasStdExtM", "true",
                        "'M' (Integer Multiplication and Division)">;
diff --git a/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp b/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
index bb55c16bf135..ddc61121a2bf 100644
--- a/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
+++ b/llvm/lib/Target/RISCV/RISCVFrameLowering.cpp
@@ -27,6 +27,21 @@
 
 using namespace llvm;
 
+static Align getABIStackAlignment(RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E)
+    return Align(4);
+  if (ABI == RISCVABI::ABI_LP64E)
+    return Align(8);
+  return Align(16);
+}
+
+RISCVFrameLowering::RISCVFrameLowering(const RISCVSubtarget &STI)
+    : TargetFrameLowering(StackGrowsDown,
+                          getABIStackAlignment(STI.getTargetABI()),
+                          /*LocalAreaOffset=*/0,
+                          /*TransientStackAlignment=*/Align(16)),
+      STI(STI) {}
+
 // For now we use x18, a.k.a s2, as pointer to shadow call stack.
 // User should explicitly set -ffixed-x18 and not use x18 in their asm.
 static void emitSCSPrologue(MachineFunction &MF, MachineBasicBlock &MBB,
@@ -444,7 +459,8 @@ void RISCVFrameLowering::emitPrologue(MachineFunction &MF,
   if (int LibCallRegs = getLibCallID(MF, MFI.getCalleeSavedInfo()) + 1) {
     // Calculate the size of the frame managed by the libcall. The libcalls are
     // implemented such that the stack will always be 16 byte aligned.
-    unsigned LibCallFrameSize = alignTo((STI.getXLen() / 8) * LibCallRegs, 16);
+    unsigned LibCallFrameSize =
+        alignTo((STI.getXLen() / 8) * LibCallRegs, getStackAlign());
     RVFI->setLibCallStackSize(LibCallFrameSize);
   }
 
diff --git a/llvm/lib/Target/RISCV/RISCVFrameLowering.h b/llvm/lib/Target/RISCV/RISCVFrameLowering.h
index bf6c1a652629..256c010bd820 100644
--- a/llvm/lib/Target/RISCV/RISCVFrameLowering.h
+++ b/llvm/lib/Target/RISCV/RISCVFrameLowering.h
@@ -21,12 +21,7 @@ class RISCVSubtarget;
 
 class RISCVFrameLowering : public TargetFrameLowering {
 public:
-  explicit RISCVFrameLowering(const RISCVSubtarget &STI)
-      : TargetFrameLowering(StackGrowsDown,
-                            /*StackAlignment=*/Align(16),
-                            /*LocalAreaOffset=*/0,
-                            /*TransientStackAlignment=*/Align(16)),
-        STI(STI) {}
+  explicit RISCVFrameLowering(const RISCVSubtarget &STI);
 
   void emitPrologue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
   void emitEpilogue(MachineFunction &MF, MachineBasicBlock &MBB) const override;
diff --git a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
index 6eea169f8919..a1c3082dda68 100644
--- a/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
+++ b/llvm/lib/Target/RISCV/RISCVISelLowering.cpp
@@ -69,9 +69,6 @@ RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
                                          const RISCVSubtarget &STI)
     : TargetLowering(TM), Subtarget(STI) {
 
-  if (Subtarget.isRV32E())
-    report_fatal_error("Codegen not yet implemented for RV32E");
-
   RISCVABI::ABI ABI = Subtarget.getTargetABI();
   assert(ABI != RISCVABI::ABI_Unknown && "Improperly initialised target ABI");
 
@@ -95,6 +92,8 @@ RISCVTargetLowering::RISCVTargetLowering(const TargetMachine &TM,
   case RISCVABI::ABI_ILP32:
   case RISCVABI::ABI_ILP32F:
   case RISCVABI::ABI_ILP32D:
+  case RISCVABI::ABI_ILP32E:
+  case RISCVABI::ABI_LP64E:
   case RISCVABI::ABI_LP64:
   case RISCVABI::ABI_LP64F:
   case RISCVABI::ABI_LP64D:
@@ -11887,10 +11886,15 @@ void RISCVTargetLowering::AdjustInstrPostInstrSelection(MachineInstr &MI,
 // register-size fields in the same situations they would be for fixed
 // arguments.
 
-static const MCPhysReg ArgGPRs[] = {
-  RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13,
-  RISCV::X14, RISCV::X15, RISCV::X16, RISCV::X17
-};
+// The GPRs used for passing arguments in the ILP32* and LP64* ABIs, except
+// the ILP32E ABI.
+static const MCPhysReg ArgIGPRs[] = {RISCV::X10, RISCV::X11, RISCV::X12,
+                                     RISCV::X13, RISCV::X14, RISCV::X15,
+                                     RISCV::X16, RISCV::X17};
+// The GPRs used for passing arguments in the ILP32E/ILP64E ABI.
+static const MCPhysReg ArgEGPRs[] = {RISCV::X10, RISCV::X11, RISCV::X12,
+                                     RISCV::X13, RISCV::X14, RISCV::X15};
+// The FPRs used for passing arguments in the ILP32F and LP64F ABIs.
 static const MCPhysReg ArgFPR16s[] = {
   RISCV::F10_H, RISCV::F11_H, RISCV::F12_H, RISCV::F13_H,
   RISCV::F14_H, RISCV::F15_H, RISCV::F16_H, RISCV::F17_H
@@ -11899,6 +11903,7 @@ static const MCPhysReg ArgFPR32s[] = {
   RISCV::F10_F, RISCV::F11_F, RISCV::F12_F, RISCV::F13_F,
   RISCV::F14_F, RISCV::F15_F, RISCV::F16_F, RISCV::F17_F
 };
+// The FPRs used for passing arguments in the ILP32D and LP64D ABIs.
 static const MCPhysReg ArgFPR64s[] = {
   RISCV::F10_D, RISCV::F11_D, RISCV::F12_D, RISCV::F13_D,
   RISCV::F14_D, RISCV::F15_D, RISCV::F16_D, RISCV::F17_D
@@ -11915,21 +11920,61 @@ static const MCPhysReg ArgVRM4s[] = {RISCV::V8M4, RISCV::V12M4, RISCV::V16M4,
                                      RISCV::V20M4};
 static const MCPhysReg ArgVRM8s[] = {RISCV::V8M8, RISCV::V16M8};
 
+// The GPRs used for passing arguments in the FastCC, X5 and X6 might be used
+// for save-restore libcall, so we don't use them.
+static const MCPhysReg FastCCIGPRs[] = {
+    RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13, RISCV::X14,
+    RISCV::X15, RISCV::X16, RISCV::X17, RISCV::X7,  RISCV::X28,
+    RISCV::X29, RISCV::X30, RISCV::X31};
+
+// The GPRs used for passing arguments in the FastCC when using ILP32E/ILP64E.
+static const MCPhysReg FastCCEGPRs[] = {RISCV::X10, RISCV::X11, RISCV::X12,
+                                        RISCV::X13, RISCV::X14, RISCV::X15,
+                                        RISCV::X7};
+
+static ArrayRef<MCPhysReg> getCallingConvArgGPRs(const RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E || ABI == RISCVABI::ABI_LP64E)
+    return ArrayRef(ArgEGPRs);
+
+  return ArrayRef(ArgIGPRs);
+}
+
+static ArrayRef<MCPhysReg> getFastCCGPRs(const RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E || ABI == RISCVABI::ABI_LP64E)
+    return ArrayRef(FastCCEGPRs);
+
+  return ArrayRef(FastCCIGPRs);
+}
+
+static Register getCallingConvLastArgGPR(const RISCVABI::ABI ABI) {
+  if (ABI == RISCVABI::ABI_ILP32E || ABI == RISCVABI::ABI_LP64E)
+    return RISCV::X15;
+
+  return RISCV::X17;
+}
+
 // Pass a 2*XLEN argument that has been split into two XLEN values through
 // registers or the stack as necessary.
 static bool CC_RISCVAssign2XLen(unsigned XLen, CCState &State, CCValAssign VA1,
                                 ISD::ArgFlagsTy ArgFlags1, unsigned ValNo2,
                                 MVT ValVT2, MVT LocVT2,
-                                ISD::ArgFlagsTy ArgFlags2) {
+                                ISD::ArgFlagsTy ArgFlags2, bool EABI) {
   unsigned XLenInBytes = XLen / 8;
+  const RISCVSubtarget &STI =
+      State.getMachineFunction().getSubtarget<RISCVSubtarget>();
+  ArrayRef<MCPhysReg> ArgGPRs = getCallingConvArgGPRs(STI.getTargetABI());
   if (Register Reg = State.AllocateReg(ArgGPRs)) {
     // At least one half can be passed via register.
     State.addLoc(CCValAssign::getReg(VA1.getValNo(), VA1.getValVT(), Reg,
                                      VA1.getLocVT(), CCValAssign::Full));
   } else {
     // Both halves must be passed on the stack, with proper alignment.
+    // TODO: To be compatible with GCC's behaviors, we force them to have 4-byte
+    // alignment. This behavior may be changed when RV32E/ILP32E is ratified.
     Align StackAlign =
-        std::max(Align(XLenInBytes), ArgFlags1.getNonZeroOrigAlign());
+        EABI && XLen == 32
+            ? Align(XLenInBytes)
+            : std::max(Align(XLenInBytes), ArgFlags1.getNonZeroOrigAlign());
     State.addLoc(
         CCValAssign::getMem(VA1.getValNo(), VA1.getValVT(),
                             State.AllocateStack(XLenInBytes, StackAlign),
@@ -12010,7 +12055,9 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
   default:
     llvm_unreachable("Unexpected ABI");
   case RISCVABI::ABI_ILP32:
+  case RISCVABI::ABI_ILP32E:
   case RISCVABI::ABI_LP64:
+  case RISCVABI::ABI_LP64E:
     break;
   case RISCVABI::ABI_ILP32F:
   case RISCVABI::ABI_LP64F:
@@ -12041,6 +12088,8 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
     LocInfo = CCValAssign::BCvt;
   }
 
+  ArrayRef<MCPhysReg> ArgGPRs = getCallingConvArgGPRs(ABI);
+
   // If this is a variadic argument, the RISC-V calling convention requires
   // that it is assigned an 'even' or 'aligned' register if it has 8-byte
   // alignment (RV32) or 16-byte alignment (RV64). An aligned register should
@@ -12048,9 +12097,13 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
   // legalisation or not. The argument will not be passed by registers if the
   // original type is larger than 2*XLEN, so the register alignment rule does
   // not apply.
+  // TODO: To be compatible with GCC's behaviors, we don't align registers
+  // currently if we are using ILP32E calling convention. This behavior may be
+  // changed when RV32E/ILP32E is ratified.
   unsigned TwoXLenInBytes = (2 * XLen) / 8;
   if (!IsFixed && ArgFlags.getNonZeroOrigAlign() == TwoXLenInBytes &&
-      DL.getTypeAllocSize(OrigTy) == TwoXLenInBytes) {
+      DL.getTypeAllocSize(OrigTy) == TwoXLenInBytes &&
+      ABI != RISCVABI::ABI_ILP32E) {
     unsigned RegIdx = State.getFirstUnallocated(ArgGPRs);
     // Skip 'odd' register if necessary.
     if (RegIdx != std::size(ArgGPRs) && RegIdx % 2 == 1)
@@ -12117,8 +12170,9 @@ static bool CC_RISCV(const DataLayout &DL, RISCVABI::ABI ABI, unsigned ValNo,
     ISD::ArgFlagsTy AF = PendingArgFlags[0];
     PendingLocs.clear();
     PendingArgFlags.clear();
-    return CC_RISCVAssign2XLen(XLen, State, VA, AF, ValNo, ValVT, LocVT,
-                               ArgFlags);
+    return CC_RISCVAssign2XLen(
+        XLen, State, VA, AF, ValNo, ValVT, LocVT, ArgFlags,
+        ABI == RISCVABI::ABI_ILP32E || ABI == RISCVABI::ABI_LP64E);
   }
 
   // Allocate to a register if possible, or else a stack slot.
@@ -12395,6 +12449,7 @@ static SDValue unpackF64OnRV32DSoftABI(SelectionDAG &DAG, SDValue Chain,
   MachineFunction &MF = DAG.getMachineFunction();
   MachineFrameInfo &MFI = MF.getFrameInfo();
   MachineRegisterInfo &RegInfo = MF.getRegInfo();
+  const RISCVSubtarget &STI = MF.getSubtarget<RISCVSubtarget>();
 
   if (VA.isMemLoc()) {
     // f64 is passed on the stack.
@@ -12411,7 +12466,7 @@ static SDValue unpackF64OnRV32DSoftABI(SelectionDAG &DAG, SDValue Chain,
   RegInfo.addLiveIn(VA.getLocReg(), LoVReg);
   SDValue Lo = DAG.getCopyFromReg(Chain, DL, LoVReg, MVT::i32);
   SDValue Hi;
-  if (VA.getLocReg() == RISCV::X17) {
+  if (VA.getLocReg() == getCallingConvLastArgGPR(STI.getTargetABI())) {
     // Second half of f64 is passed on the stack.
     int FI = MFI.CreateFixedObject(4, 0, /*IsImmutable=*/true);
     SDValue FIN = DAG.getFrameIndex(FI, MVT::i32);
@@ -12435,15 +12490,8 @@ static bool CC_RISCV_FastCC(const DataLayout &DL, RISCVABI::ABI ABI,
                             bool IsFixed, bool IsRet, Type *OrigTy,
                             const RISCVTargetLowering &TLI,
                             std::optional<unsigned> FirstMaskArgument) {
-
-  // X5 and X6 might be used for save-restore libcall.
-  static const MCPhysReg GPRList[] = {
-      RISCV::X10, RISCV::X11, RISCV::X12, RISCV::X13, RISCV::X14,
-      RISCV::X15, RISCV::X16, RISCV::X17, RISCV::X7,  RISCV::X28,
-      RISCV::X29, RISCV::X30, RISCV::X31};
-
   if (LocVT == MVT::i32 || LocVT == MVT::i64) {
-    if (unsigned Reg = State.AllocateReg(GPRList)) {
+    if (unsigned Reg = State.AllocateReg(getFastCCGPRs(ABI))) {
       State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));
       return false;
     }
@@ -12507,7 +12555,7 @@ static bool CC_RISCV_FastCC(const DataLayout &DL, RISCVABI::ABI ABI,
       State.addLoc(CCValAssign::getReg(ValNo, ValVT, Reg, LocVT, LocInfo));
     } else {
       // Try and pass the address via a "fast" GPR.
-      if (unsigned GPRReg = State.AllocateReg(GPRList)) {
+      if (unsigned GPRReg = State.AllocateReg(getFastCCGPRs(ABI))) {
         LocInfo = CCValAssign::Indirect;
         LocVT = TLI.getSubtarget().getXLenVT();
         State.addLoc(CCValAssign::getReg(ValNo, ValVT, GPRReg, LocVT, LocInfo));
@@ -12594,6 +12642,8 @@ SDValue RISCVTargetLowering::LowerFormalArguments(
   case CallingConv::Fast:
     break;
   case CallingConv::GHC:
+    if (Subtarget.isRV32E())
+      report_fatal_error("GHC calling convention is not supported on RVE!");
     if (!MF.getSubtarget().getFeatureBits()[RISCV::FeatureStdExtF] ||
         !MF.getSubtarget().getFeatureBits()[RISCV::FeatureStdExtD])
       report_fatal_error(
@@ -12617,6 +12667,7 @@ SDValue RISCVTargetLowering::LowerFormalArguments(
   EVT PtrVT = getPointerTy(DAG.getDataLayout());
   MVT XLenVT = Subtarget.getXLenVT();
   unsigned XLenInBytes = Subtarget.getXLen() / 8;
+  RISCVABI::ABI ABI = Subtarget.getTargetABI();
   // Used with vargs to acumulate store chains.
   std::vector<SDValue> OutChains;
 
@@ -12675,7 +12726,7 @@ SDValue RISCVTargetLowering::LowerFormalArguments(
     MF.getInfo<RISCVMachineFunctionInfo>()->setIsVectorCall();
 
   if (IsVarArg) {
-    ArrayRef<MCPhysReg> ArgRegs = ArrayRef(ArgGPRs);
+    ArrayRef<MCPhysReg> ArgRegs = getCallingConvArgGPRs(ABI);
     unsigned Idx = CCInfo.getFirstUnallocated(ArgRegs);
     const TargetRegisterClass *RC = &RISCV::GPRRegClass;
     MachineFrameInfo &MFI = MF.getFrameInfo();
@@ -12840,9 +12891,11 @@ SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
   SmallVector<CCValAssign, 16> ArgLocs;
   CCState ArgCCInfo(CallConv, IsVarArg, MF, ArgLocs, *DAG.getContext());
 
-  if (CallConv == CallingConv::GHC)
+  if (CallConv == CallingConv::GHC) {
+    if (Subtarget.isRV32E())
+      report_fatal_error("GHC calling convention is not supported on RVE!");
     ArgCCInfo.AnalyzeCallOperands(Outs, CC_RISCV_GHC);
-  else
+  } else
     analyzeOutputArgs(MF, ArgCCInfo, Outs, /*IsRet=*/false, &CLI,
                       CallConv == CallingConv::Fast ? CC_RISCV_FastCC
                                                     : CC_RISCV);
@@ -12907,7 +12960,7 @@ SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
       Register RegLo = VA.getLocReg();
       RegsToPass.push_back(std::make_pair(RegLo, Lo));
 
-      if (RegLo == RISCV::X17) {
+      if (RegLo == getCallingConvLastArgGPR(Subtarget.getTargetABI())) {
         // Second half of f64 is passed on the stack.
         // Work out the address of the stack slot.
         if (!StackPtr.getNode())
@@ -13099,9 +13152,9 @@ SDValue RISCVTargetLowering::LowerCall(CallLoweringInfo &CLI,
     Glue = RetValue.getValue(2);
 
     if (VA.getLocVT() == MVT::i32 && VA.getValVT() == MVT::f64) {
-      assert(VA.getLocReg() == ArgGPRs[0] && "Unexpected reg assignment");
+      assert(VA.getLocReg() == RISCV::X10 && "Unexpected reg assignment");
       SDValue RetValue2 =
-          DAG.getCopyFromReg(Chain, DL, ArgGPRs[1], MVT::i32, Glue);
+          DAG.getCopyFromReg(Chain, DL, RISCV::X11, MVT::i32, Glue);
       Chain = RetValue2.getValue(1);
       Glue = RetValue2.getValue(2);
       RetValue = DAG.getNode(RISCVISD::BuildPairF64, DL, MVT::f64, RetValue,
diff --git a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
index 927845aa23d1..26d23b11748d 100644
--- a/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
+++ b/llvm/lib/Target/RISCV/RISCVRegisterInfo.cpp
@@ -69,6 +69,9 @@ RISCVRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
   switch (Subtarget.getTargetABI()) {
   default:
     llvm_unreachable("Unrecognized ABI");
+  case RISCVABI::ABI_ILP32E:
+  case RISCVABI::ABI_LP64E:
+    return CSR_ILP32E_LP64E_SaveList;
   case RISCVABI::ABI_ILP32:
   case RISCVABI::ABI_LP64:
     return CSR_ILP32_LP64_SaveList;
@@ -82,12 +85,13 @@ RISCVRegisterInfo::getCalleeSavedRegs(const MachineFunction *MF) const {
 }
 
 BitVector RISCVRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
+  const RISCVSubtarget &STI = MF.getSubtarget<RISCVSubtarget>();
   const RISCVFrameLowering *TFI = getFrameLowering(MF);
   BitVector Reserved(getNumRegs());
 
   // Mark any registers requested to be reserved as such
   for (size_t Reg = 0; Reg < getNumRegs(); Reg++) {
-    if (MF.getSubtarget<RISCVSubtarget>().isRegisterReservedByUser(Reg))
+    if (STI.isRegisterReservedByUser(Reg))
       markSuperRegs(Reserved, Reg);
   }
 
@@ -103,6 +107,11 @@ BitVector RISCVRegisterInfo::getReservedRegs(const MachineFunction &MF) const {
   if (TFI->hasBP(MF))
     markSuperRegs(Reserved, RISCVABI::getBPReg()); // bp
 
+  // There are only 16 GPRs for RVE.
+  if (STI.isRV32E())
+    for (size_t Reg = RISCV::X16; Reg <= RISCV::X31; Reg++)
+      markSuperRegs(Reserved, Reg);
+
   // V registers for code generation. We handle them manually.
   markSuperRegs(Reserved, RISCV::VL);
   markSuperRegs(Reserved, RISCV::VTYPE);
@@ -634,6 +643,9 @@ RISCVRegisterInfo::getCallPreservedMask(const MachineFunction & MF,
   switch (Subtarget.getTargetABI()) {
   default:
     llvm_unreachable("Unrecognized ABI");
+  case RISCVABI::ABI_ILP32E:
+  case RISCVABI::ABI_LP64E:
+    return CSR_ILP32E_LP64E_RegMask;
   case RISCVABI::ABI_ILP32:
   case RISCVABI::ABI_LP64:
     return CSR_ILP32_LP64_RegMask;
diff --git a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
index cc881406666c..e81a9309f7cb 100644
--- a/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
+++ b/llvm/lib/Target/RISCV/RISCVTargetMachine.cpp
@@ -84,10 +84,20 @@ extern "C" LLVM_EXTERNAL_VISIBILITY void LLVMInitializeRISCVTarget() {
   initializeRISCVDAGToDAGISelPass(*PR);
 }
 
-static StringRef computeDataLayout(const Triple &TT) {
-  if (TT.isArch64Bit())
+static StringRef computeDataLayout(const Triple &TT,
+                                   const TargetOptions &Options) {
+  StringRef ABIName = Options.MCOptions.getABIName();
+  if (TT.isArch64Bit()) {
+    if (ABIName == "lp64e")
+      return "e-m:e-p:64:64-i64:64-i128:128-n32:64-S64";
+
     return "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128";
+  }
   assert(TT.isArch32Bit() && "only RV32 and RV64 are currently supported");
+
+  if (ABIName == "ilp32e")
+    return "e-m:e-p:32:32-i64:64-n32-S32";
+
   return "e-m:e-p:32:32-i64:64-n32-S128";
 }
 
@@ -102,7 +112,7 @@ RISCVTargetMachine::RISCVTargetMachine(const Target &T, const Triple &TT,
                                        std::optional<Reloc::Model> RM,
                                        std::optional<CodeModel::Model> CM,
                                        CodeGenOpt::Level OL, bool JIT)
-    : LLVMTargetMachine(T, computeDataLayout(TT), TT, CPU, FS, Options,
+    : LLVMTargetMachine(T, computeDataLayout(TT, Options), TT, CPU, FS, Options,
                         getEffectiveRelocModel(TT, RM),
                         getEffectiveCodeModel(CM, CodeModel::Small), OL),
       TLOF(std::make_unique<RISCVELFTargetObjectFile>()) {
diff --git a/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll b/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll
index 18b601163fa4..979cdff72af0 100644
--- a/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll
+++ b/llvm/test/CodeGen/RISCV/callee-saved-fpr32s.ll
@@ -1,8 +1,12 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -mattr=+f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=ILP32
+; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=ILP32E
 ; RUN: llc -mtriple=riscv64 -mattr=+f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=LP64
+; RUN: llc -mtriple=riscv64 -mattr=+f -target-abi lp64e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=LP64E
 ; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=ILP32F
 ; RUN: llc -mtriple=riscv64 -mattr=+f -target-abi lp64f -verify-machineinstrs < %s \
@@ -14,8 +18,8 @@
 
 @var = global [32 x float] zeroinitializer
 
-; All floating point registers are temporaries for the ilp32 and lp64 ABIs.
-; fs0-fs11 are callee-saved for the ilp32f, ilp32d, lp64f, and lp64d ABIs.
+; All floating point registers are temporaries for the ilp32, ilp32e, lp64e and lp64
+; ABIs. fs0-fs11 are callee-saved for the ilp32f, ilp32d, lp64f, and lp64d ABIs.
 
 ; This function tests that RISCVRegisterInfo::getCalleeSavedRegs returns
 ; something appropriate.
@@ -91,6 +95,76 @@ define void @callee() nounwind {
 ; ILP32-NEXT:    fsw ft0, %lo(var)(a0)
 ; ILP32-NEXT:    ret
 ;
+; ILP32E-LABEL: callee:
+; ILP32E:       # %bb.0:
+; ILP32E-NEXT:    lui a0, %hi(var)
+; ILP32E-NEXT:    flw ft0, %lo(var)(a0)
+; ILP32E-NEXT:    flw ft1, %lo(var+4)(a0)
+; ILP32E-NEXT:    flw ft2, %lo(var+8)(a0)
+; ILP32E-NEXT:    flw ft3, %lo(var+12)(a0)
+; ILP32E-NEXT:    addi a1, a0, %lo(var)
+; ILP32E-NEXT:    flw ft4, 16(a1)
+; ILP32E-NEXT:    flw ft5, 20(a1)
+; ILP32E-NEXT:    flw ft6, 24(a1)
+; ILP32E-NEXT:    flw ft7, 28(a1)
+; ILP32E-NEXT:    flw fa0, 32(a1)
+; ILP32E-NEXT:    flw fa1, 36(a1)
+; ILP32E-NEXT:    flw fa2, 40(a1)
+; ILP32E-NEXT:    flw fa3, 44(a1)
+; ILP32E-NEXT:    flw fa4, 48(a1)
+; ILP32E-NEXT:    flw fa5, 52(a1)
+; ILP32E-NEXT:    flw fa6, 56(a1)
+; ILP32E-NEXT:    flw fa7, 60(a1)
+; ILP32E-NEXT:    flw ft8, 64(a1)
+; ILP32E-NEXT:    flw ft9, 68(a1)
+; ILP32E-NEXT:    flw ft10, 72(a1)
+; ILP32E-NEXT:    flw ft11, 76(a1)
+; ILP32E-NEXT:    flw fs0, 80(a1)
+; ILP32E-NEXT:    flw fs1, 84(a1)
+; ILP32E-NEXT:    flw fs2, 88(a1)
+; ILP32E-NEXT:    flw fs3, 92(a1)
+; ILP32E-NEXT:    flw fs4, 96(a1)
+; ILP32E-NEXT:    flw fs5, 100(a1)
+; ILP32E-NEXT:    flw fs6, 104(a1)
+; ILP32E-NEXT:    flw fs7, 108(a1)
+; ILP32E-NEXT:    flw fs8, 124(a1)
+; ILP32E-NEXT:    flw fs9, 120(a1)
+; ILP32E-NEXT:    flw fs10, 116(a1)
+; ILP32E-NEXT:    flw fs11, 112(a1)
+; ILP32E-NEXT:    fsw fs8, 124(a1)
+; ILP32E-NEXT:    fsw fs9, 120(a1)
+; ILP32E-NEXT:    fsw fs10, 116(a1)
+; ILP32E-NEXT:    fsw fs11, 112(a1)
+; ILP32E-NEXT:    fsw fs7, 108(a1)
+; ILP32E-NEXT:    fsw fs6, 104(a1)
+; ILP32E-NEXT:    fsw fs5, 100(a1)
+; ILP32E-NEXT:    fsw fs4, 96(a1)
+; ILP32E-NEXT:    fsw fs3, 92(a1)
+; ILP32E-NEXT:    fsw fs2, 88(a1)
+; ILP32E-NEXT:    fsw fs1, 84(a1)
+; ILP32E-NEXT:    fsw fs0, 80(a1)
+; ILP32E-NEXT:    fsw ft11, 76(a1)
+; ILP32E-NEXT:    fsw ft10, 72(a1)
+; ILP32E-NEXT:    fsw ft9, 68(a1)
+; ILP32E-NEXT:    fsw ft8, 64(a1)
+; ILP32E-NEXT:    fsw fa7, 60(a1)
+; ILP32E-NEXT:    fsw fa6, 56(a1)
+; ILP32E-NEXT:    fsw fa5, 52(a1)
+; ILP32E-NEXT:    fsw fa4, 48(a1)
+; ILP32E-NEXT:    fsw fa3, 44(a1)
+; ILP32E-NEXT:    fsw fa2, 40(a1)
+; ILP32E-NEXT:    fsw fa1, 36(a1)
+; ILP32E-NEXT:    fsw fa0, 32(a1)
+; ILP32E-NEXT:    fsw ft7, 28(a1)
+; ILP32E-NEXT:    fsw ft6, 24(a1)
+; ILP32E-NEXT:    fsw ft5, 20(a1)
+; ILP32E-NEXT:    fsw ft4, 16(a1)
+; ILP32E-NEXT:    fsw ft3, %lo(var+12)(a0)
+; ILP32E-NEXT:    fsw ft2, %lo(var+8)(a0)
+; ILP32E-NEXT:    fsw ft1, %lo(var+4)(a0)
+; ILP32E-NEXT:    fsw ft0, %lo(var)(a0)
+; ILP32E-NEXT:    ret
+;
 ; LP64-LABEL: callee:
 ; LP64:       # %bb.0:
 ; LP64-NEXT:    lui a0, %hi(var)
@@ -161,6 +235,76 @@ define void @callee() nounwind {
 ; LP64-NEXT:    fsw ft0, %lo(var)(a0)
 ; LP64-NEXT:    ret
 ;
+; LP64E-LABEL: callee:
+; LP64E:       # %bb.0:
+; LP64E-NEXT:    lui a0, %hi(var)
+; LP64E-NEXT:    flw ft0, %lo(var)(a0)
+; LP64E-NEXT:    flw ft1, %lo(var+4)(a0)
+; LP64E-NEXT:    flw ft2, %lo(var+8)(a0)
+; LP64E-NEXT:    flw ft3, %lo(var+12)(a0)
+; LP64E-NEXT:    addi a1, a0, %lo(var)
+; LP64E-NEXT:    flw ft4, 16(a1)
+; LP64E-NEXT:    flw ft5, 20(a1)
+; LP64E-NEXT:    flw ft6, 24(a1)
+; LP64E-NEXT:    flw ft7, 28(a1)
+; LP64E-NEXT:    flw fa0, 32(a1)
+; LP64E-NEXT:    flw fa1, 36(a1)
+; LP64E-NEXT:    flw fa2, 40(a1)
+; LP64E-NEXT:    flw fa3, 44(a1)
+; LP64E-NEXT:    flw fa4, 48(a1)
+; LP64E-NEXT:    flw fa5, 52(a1)
+; LP64E-NEXT:    flw fa6, 56(a1)
+; LP64E-NEXT:    flw fa7, 60(a1)
+; LP64E-NEXT:    flw ft8, 64(a1)
+; LP64E-NEXT:    flw ft9, 68(a1)
+; LP64E-NEXT:    flw ft10, 72(a1)
+; LP64E-NEXT:    flw ft11, 76(a1)
+; LP64E-NEXT:    flw fs0, 80(a1)
+; LP64E-NEXT:    flw fs1, 84(a1)
+; LP64E-NEXT:    flw fs2, 88(a1)
+; LP64E-NEXT:    flw fs3, 92(a1)
+; LP64E-NEXT:    flw fs4, 96(a1)
+; LP64E-NEXT:    flw fs5, 100(a1)
+; LP64E-NEXT:    flw fs6, 104(a1)
+; LP64E-NEXT:    flw fs7, 108(a1)
+; LP64E-NEXT:    flw fs8, 124(a1)
+; LP64E-NEXT:    flw fs9, 120(a1)
+; LP64E-NEXT:    flw fs10, 116(a1)
+; LP64E-NEXT:    flw fs11, 112(a1)
+; LP64E-NEXT:    fsw fs8, 124(a1)
+; LP64E-NEXT:    fsw fs9, 120(a1)
+; LP64E-NEXT:    fsw fs10, 116(a1)
+; LP64E-NEXT:    fsw fs11, 112(a1)
+; LP64E-NEXT:    fsw fs7, 108(a1)
+; LP64E-NEXT:    fsw fs6, 104(a1)
+; LP64E-NEXT:    fsw fs5, 100(a1)
+; LP64E-NEXT:    fsw fs4, 96(a1)
+; LP64E-NEXT:    fsw fs3, 92(a1)
+; LP64E-NEXT:    fsw fs2, 88(a1)
+; LP64E-NEXT:    fsw fs1, 84(a1)
+; LP64E-NEXT:    fsw fs0, 80(a1)
+; LP64E-NEXT:    fsw ft11, 76(a1)
+; LP64E-NEXT:    fsw ft10, 72(a1)
+; LP64E-NEXT:    fsw ft9, 68(a1)
+; LP64E-NEXT:    fsw ft8, 64(a1)
+; LP64E-NEXT:    fsw fa7, 60(a1)
+; LP64E-NEXT:    fsw fa6, 56(a1)
+; LP64E-NEXT:    fsw fa5, 52(a1)
+; LP64E-NEXT:    fsw fa4, 48(a1)
+; LP64E-NEXT:    fsw fa3, 44(a1)
+; LP64E-NEXT:    fsw fa2, 40(a1)
+; LP64E-NEXT:    fsw fa1, 36(a1)
+; LP64E-NEXT:    fsw fa0, 32(a1)
+; LP64E-NEXT:    fsw ft7, 28(a1)
+; LP64E-NEXT:    fsw ft6, 24(a1)
+; LP64E-NEXT:    fsw ft5, 20(a1)
+; LP64E-NEXT:    fsw ft4, 16(a1)
+; LP64E-NEXT:    fsw ft3, %lo(var+12)(a0)
+; LP64E-NEXT:    fsw ft2, %lo(var+8)(a0)
+; LP64E-NEXT:    fsw ft1, %lo(var+4)(a0)
+; LP64E-NEXT:    fsw ft0, %lo(var)(a0)
+; LP64E-NEXT:    ret
+;
 ; ILP32F-LABEL: callee:
 ; ILP32F:       # %bb.0:
 ; ILP32F-NEXT:    addi sp, sp, -48
@@ -700,6 +844,149 @@ define void @caller() nounwind {
 ; ILP32-NEXT:    addi sp, sp, 144
 ; ILP32-NEXT:    ret
 ;
+; ILP32E-LABEL: caller:
+; ILP32E:       # %bb.0:
+; ILP32E-NEXT:    addi sp, sp, -140
+; ILP32E-NEXT:    sw ra, 136(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    sw s0, 132(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    sw s1, 128(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    lui s0, %hi(var)
+; ILP32E-NEXT:    flw ft0, %lo(var)(s0)
+; ILP32E-NEXT:    fsw ft0, 124(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, %lo(var+4)(s0)
+; ILP32E-NEXT:    fsw ft0, 120(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, %lo(var+8)(s0)
+; ILP32E-NEXT:    fsw ft0, 116(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, %lo(var+12)(s0)
+; ILP32E-NEXT:    fsw ft0, 112(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    addi s1, s0, %lo(var)
+; ILP32E-NEXT:    flw ft0, 16(s1)
+; ILP32E-NEXT:    fsw ft0, 108(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 20(s1)
+; ILP32E-NEXT:    fsw ft0, 104(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 24(s1)
+; ILP32E-NEXT:    fsw ft0, 100(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 28(s1)
+; ILP32E-NEXT:    fsw ft0, 96(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 32(s1)
+; ILP32E-NEXT:    fsw ft0, 92(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 36(s1)
+; ILP32E-NEXT:    fsw ft0, 88(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 40(s1)
+; ILP32E-NEXT:    fsw ft0, 84(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 44(s1)
+; ILP32E-NEXT:    fsw ft0, 80(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 48(s1)
+; ILP32E-NEXT:    fsw ft0, 76(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 52(s1)
+; ILP32E-NEXT:    fsw ft0, 72(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 56(s1)
+; ILP32E-NEXT:    fsw ft0, 68(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 60(s1)
+; ILP32E-NEXT:    fsw ft0, 64(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 64(s1)
+; ILP32E-NEXT:    fsw ft0, 60(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 68(s1)
+; ILP32E-NEXT:    fsw ft0, 56(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 72(s1)
+; ILP32E-NEXT:    fsw ft0, 52(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 76(s1)
+; ILP32E-NEXT:    fsw ft0, 48(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 80(s1)
+; ILP32E-NEXT:    fsw ft0, 44(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 84(s1)
+; ILP32E-NEXT:    fsw ft0, 40(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 88(s1)
+; ILP32E-NEXT:    fsw ft0, 36(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 92(s1)
+; ILP32E-NEXT:    fsw ft0, 32(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 96(s1)
+; ILP32E-NEXT:    fsw ft0, 28(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 100(s1)
+; ILP32E-NEXT:    fsw ft0, 24(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 104(s1)
+; ILP32E-NEXT:    fsw ft0, 20(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 108(s1)
+; ILP32E-NEXT:    fsw ft0, 16(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 112(s1)
+; ILP32E-NEXT:    fsw ft0, 12(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 116(s1)
+; ILP32E-NEXT:    fsw ft0, 8(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 120(s1)
+; ILP32E-NEXT:    fsw ft0, 4(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    flw ft0, 124(s1)
+; ILP32E-NEXT:    fsw ft0, 0(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    call callee@plt
+; ILP32E-NEXT:    flw ft0, 0(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 124(s1)
+; ILP32E-NEXT:    flw ft0, 4(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 120(s1)
+; ILP32E-NEXT:    flw ft0, 8(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 116(s1)
+; ILP32E-NEXT:    flw ft0, 12(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 112(s1)
+; ILP32E-NEXT:    flw ft0, 16(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 108(s1)
+; ILP32E-NEXT:    flw ft0, 20(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 104(s1)
+; ILP32E-NEXT:    flw ft0, 24(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 100(s1)
+; ILP32E-NEXT:    flw ft0, 28(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 96(s1)
+; ILP32E-NEXT:    flw ft0, 32(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 92(s1)
+; ILP32E-NEXT:    flw ft0, 36(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 88(s1)
+; ILP32E-NEXT:    flw ft0, 40(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 84(s1)
+; ILP32E-NEXT:    flw ft0, 44(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 80(s1)
+; ILP32E-NEXT:    flw ft0, 48(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 76(s1)
+; ILP32E-NEXT:    flw ft0, 52(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 72(s1)
+; ILP32E-NEXT:    flw ft0, 56(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 68(s1)
+; ILP32E-NEXT:    flw ft0, 60(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 64(s1)
+; ILP32E-NEXT:    flw ft0, 64(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 60(s1)
+; ILP32E-NEXT:    flw ft0, 68(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 56(s1)
+; ILP32E-NEXT:    flw ft0, 72(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 52(s1)
+; ILP32E-NEXT:    flw ft0, 76(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 48(s1)
+; ILP32E-NEXT:    flw ft0, 80(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 44(s1)
+; ILP32E-NEXT:    flw ft0, 84(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 40(s1)
+; ILP32E-NEXT:    flw ft0, 88(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 36(s1)
+; ILP32E-NEXT:    flw ft0, 92(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 32(s1)
+; ILP32E-NEXT:    flw ft0, 96(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 28(s1)
+; ILP32E-NEXT:    flw ft0, 100(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 24(s1)
+; ILP32E-NEXT:    flw ft0, 104(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 20(s1)
+; ILP32E-NEXT:    flw ft0, 108(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, 16(s1)
+; ILP32E-NEXT:    flw ft0, 112(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var+12)(s0)
+; ILP32E-NEXT:    flw ft0, 116(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var+8)(s0)
+; ILP32E-NEXT:    flw ft0, 120(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var+4)(s0)
+; ILP32E-NEXT:    flw ft0, 124(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    fsw ft0, %lo(var)(s0)
+; ILP32E-NEXT:    lw ra, 136(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    lw s0, 132(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    lw s1, 128(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    addi sp, sp, 140
+; ILP32E-NEXT:    ret
+;
 ; LP64-LABEL: caller:
 ; LP64:       # %bb.0:
 ; LP64-NEXT:    addi sp, sp, -160
@@ -843,6 +1130,149 @@ define void @caller() nounwind {
 ; LP64-NEXT:    addi sp, sp, 160
 ; LP64-NEXT:    ret
 ;
+; LP64E-LABEL: caller:
+; LP64E:       # %bb.0:
+; LP64E-NEXT:    addi sp, sp, -152
+; LP64E-NEXT:    sd ra, 144(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    sd s0, 136(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    sd s1, 128(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    lui s0, %hi(var)
+; LP64E-NEXT:    flw ft0, %lo(var)(s0)
+; LP64E-NEXT:    fsw ft0, 124(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, %lo(var+4)(s0)
+; LP64E-NEXT:    fsw ft0, 120(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, %lo(var+8)(s0)
+; LP64E-NEXT:    fsw ft0, 116(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, %lo(var+12)(s0)
+; LP64E-NEXT:    fsw ft0, 112(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    addi s1, s0, %lo(var)
+; LP64E-NEXT:    flw ft0, 16(s1)
+; LP64E-NEXT:    fsw ft0, 108(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 20(s1)
+; LP64E-NEXT:    fsw ft0, 104(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 24(s1)
+; LP64E-NEXT:    fsw ft0, 100(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 28(s1)
+; LP64E-NEXT:    fsw ft0, 96(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 32(s1)
+; LP64E-NEXT:    fsw ft0, 92(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 36(s1)
+; LP64E-NEXT:    fsw ft0, 88(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 40(s1)
+; LP64E-NEXT:    fsw ft0, 84(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 44(s1)
+; LP64E-NEXT:    fsw ft0, 80(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 48(s1)
+; LP64E-NEXT:    fsw ft0, 76(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 52(s1)
+; LP64E-NEXT:    fsw ft0, 72(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 56(s1)
+; LP64E-NEXT:    fsw ft0, 68(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 60(s1)
+; LP64E-NEXT:    fsw ft0, 64(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 64(s1)
+; LP64E-NEXT:    fsw ft0, 60(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 68(s1)
+; LP64E-NEXT:    fsw ft0, 56(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 72(s1)
+; LP64E-NEXT:    fsw ft0, 52(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 76(s1)
+; LP64E-NEXT:    fsw ft0, 48(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 80(s1)
+; LP64E-NEXT:    fsw ft0, 44(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 84(s1)
+; LP64E-NEXT:    fsw ft0, 40(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 88(s1)
+; LP64E-NEXT:    fsw ft0, 36(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 92(s1)
+; LP64E-NEXT:    fsw ft0, 32(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 96(s1)
+; LP64E-NEXT:    fsw ft0, 28(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 100(s1)
+; LP64E-NEXT:    fsw ft0, 24(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 104(s1)
+; LP64E-NEXT:    fsw ft0, 20(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 108(s1)
+; LP64E-NEXT:    fsw ft0, 16(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 112(s1)
+; LP64E-NEXT:    fsw ft0, 12(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 116(s1)
+; LP64E-NEXT:    fsw ft0, 8(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 120(s1)
+; LP64E-NEXT:    fsw ft0, 4(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    flw ft0, 124(s1)
+; LP64E-NEXT:    fsw ft0, 0(sp) # 4-byte Folded Spill
+; LP64E-NEXT:    call callee@plt
+; LP64E-NEXT:    flw ft0, 0(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 124(s1)
+; LP64E-NEXT:    flw ft0, 4(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 120(s1)
+; LP64E-NEXT:    flw ft0, 8(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 116(s1)
+; LP64E-NEXT:    flw ft0, 12(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 112(s1)
+; LP64E-NEXT:    flw ft0, 16(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 108(s1)
+; LP64E-NEXT:    flw ft0, 20(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 104(s1)
+; LP64E-NEXT:    flw ft0, 24(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 100(s1)
+; LP64E-NEXT:    flw ft0, 28(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 96(s1)
+; LP64E-NEXT:    flw ft0, 32(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 92(s1)
+; LP64E-NEXT:    flw ft0, 36(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 88(s1)
+; LP64E-NEXT:    flw ft0, 40(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 84(s1)
+; LP64E-NEXT:    flw ft0, 44(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 80(s1)
+; LP64E-NEXT:    flw ft0, 48(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 76(s1)
+; LP64E-NEXT:    flw ft0, 52(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 72(s1)
+; LP64E-NEXT:    flw ft0, 56(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 68(s1)
+; LP64E-NEXT:    flw ft0, 60(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 64(s1)
+; LP64E-NEXT:    flw ft0, 64(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 60(s1)
+; LP64E-NEXT:    flw ft0, 68(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 56(s1)
+; LP64E-NEXT:    flw ft0, 72(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 52(s1)
+; LP64E-NEXT:    flw ft0, 76(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 48(s1)
+; LP64E-NEXT:    flw ft0, 80(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 44(s1)
+; LP64E-NEXT:    flw ft0, 84(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 40(s1)
+; LP64E-NEXT:    flw ft0, 88(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 36(s1)
+; LP64E-NEXT:    flw ft0, 92(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 32(s1)
+; LP64E-NEXT:    flw ft0, 96(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 28(s1)
+; LP64E-NEXT:    flw ft0, 100(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 24(s1)
+; LP64E-NEXT:    flw ft0, 104(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 20(s1)
+; LP64E-NEXT:    flw ft0, 108(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, 16(s1)
+; LP64E-NEXT:    flw ft0, 112(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, %lo(var+12)(s0)
+; LP64E-NEXT:    flw ft0, 116(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, %lo(var+8)(s0)
+; LP64E-NEXT:    flw ft0, 120(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, %lo(var+4)(s0)
+; LP64E-NEXT:    flw ft0, 124(sp) # 4-byte Folded Reload
+; LP64E-NEXT:    fsw ft0, %lo(var)(s0)
+; LP64E-NEXT:    ld ra, 144(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    ld s0, 136(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    ld s1, 128(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    addi sp, sp, 152
+; LP64E-NEXT:    ret
+;
 ; ILP32F-LABEL: caller:
 ; ILP32F:       # %bb.0:
 ; ILP32F-NEXT:    addi sp, sp, -144
diff --git a/llvm/test/CodeGen/RISCV/callee-saved-fpr64s.ll b/llvm/test/CodeGen/RISCV/callee-saved-fpr64s.ll
index 0e2ced0b17bf..0eb1ea33a050 100644
--- a/llvm/test/CodeGen/RISCV/callee-saved-fpr64s.ll
+++ b/llvm/test/CodeGen/RISCV/callee-saved-fpr64s.ll
@@ -3,6 +3,8 @@
 ; RUN:   | FileCheck %s -check-prefix=ILP32
 ; RUN: llc -mtriple=riscv64 -mattr=+d -target-abi=lp64 -verify-machineinstrs< %s \
 ; RUN:   | FileCheck %s -check-prefix=LP64
+; RUN: llc -mtriple=riscv64 -mattr=+d -target-abi=lp64e -verify-machineinstrs< %s \
+; RUN:   | FileCheck %s -check-prefix=LP64E
 ; RUN: llc -mtriple=riscv32 -mattr=+d -target-abi ilp32d -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=ILP32D
 ; RUN: llc -mtriple=riscv64 -mattr=+d -target-abi lp64d -verify-machineinstrs < %s \
@@ -10,7 +12,7 @@
 
 @var = global [32 x double] zeroinitializer
 
-; All floating point registers are temporaries for the ilp32 and lp64 ABIs.
+; All floating point registers are temporaries for the ilp32, lp64e and lp64 ABIs.
 ; fs0-fs11 are callee-saved for the ilp32f, ilp32d, lp64f, and lp64d ABIs.
 
 ; This function tests that RISCVRegisterInfo::getCalleeSavedRegs returns
@@ -157,6 +159,76 @@ define void @callee() nounwind {
 ; LP64-NEXT:    fsd ft0, %lo(var)(a0)
 ; LP64-NEXT:    ret
 ;
+; LP64E-LABEL: callee:
+; LP64E:       # %bb.0:
+; LP64E-NEXT:    lui a0, %hi(var)
+; LP64E-NEXT:    fld ft0, %lo(var)(a0)
+; LP64E-NEXT:    fld ft1, %lo(var+8)(a0)
+; LP64E-NEXT:    addi a1, a0, %lo(var)
+; LP64E-NEXT:    fld ft2, 16(a1)
+; LP64E-NEXT:    fld ft3, 24(a1)
+; LP64E-NEXT:    fld ft4, 32(a1)
+; LP64E-NEXT:    fld ft5, 40(a1)
+; LP64E-NEXT:    fld ft6, 48(a1)
+; LP64E-NEXT:    fld ft7, 56(a1)
+; LP64E-NEXT:    fld fa0, 64(a1)
+; LP64E-NEXT:    fld fa1, 72(a1)
+; LP64E-NEXT:    fld fa2, 80(a1)
+; LP64E-NEXT:    fld fa3, 88(a1)
+; LP64E-NEXT:    fld fa4, 96(a1)
+; LP64E-NEXT:    fld fa5, 104(a1)
+; LP64E-NEXT:    fld fa6, 112(a1)
+; LP64E-NEXT:    fld fa7, 120(a1)
+; LP64E-NEXT:    fld ft8, 128(a1)
+; LP64E-NEXT:    fld ft9, 136(a1)
+; LP64E-NEXT:    fld ft10, 144(a1)
+; LP64E-NEXT:    fld ft11, 152(a1)
+; LP64E-NEXT:    fld fs0, 160(a1)
+; LP64E-NEXT:    fld fs1, 168(a1)
+; LP64E-NEXT:    fld fs2, 176(a1)
+; LP64E-NEXT:    fld fs3, 184(a1)
+; LP64E-NEXT:    fld fs4, 192(a1)
+; LP64E-NEXT:    fld fs5, 200(a1)
+; LP64E-NEXT:    fld fs6, 208(a1)
+; LP64E-NEXT:    fld fs7, 216(a1)
+; LP64E-NEXT:    fld fs8, 248(a1)
+; LP64E-NEXT:    fld fs9, 240(a1)
+; LP64E-NEXT:    fld fs10, 232(a1)
+; LP64E-NEXT:    fld fs11, 224(a1)
+; LP64E-NEXT:    fsd fs8, 248(a1)
+; LP64E-NEXT:    fsd fs9, 240(a1)
+; LP64E-NEXT:    fsd fs10, 232(a1)
+; LP64E-NEXT:    fsd fs11, 224(a1)
+; LP64E-NEXT:    fsd fs7, 216(a1)
+; LP64E-NEXT:    fsd fs6, 208(a1)
+; LP64E-NEXT:    fsd fs5, 200(a1)
+; LP64E-NEXT:    fsd fs4, 192(a1)
+; LP64E-NEXT:    fsd fs3, 184(a1)
+; LP64E-NEXT:    fsd fs2, 176(a1)
+; LP64E-NEXT:    fsd fs1, 168(a1)
+; LP64E-NEXT:    fsd fs0, 160(a1)
+; LP64E-NEXT:    fsd ft11, 152(a1)
+; LP64E-NEXT:    fsd ft10, 144(a1)
+; LP64E-NEXT:    fsd ft9, 136(a1)
+; LP64E-NEXT:    fsd ft8, 128(a1)
+; LP64E-NEXT:    fsd fa7, 120(a1)
+; LP64E-NEXT:    fsd fa6, 112(a1)
+; LP64E-NEXT:    fsd fa5, 104(a1)
+; LP64E-NEXT:    fsd fa4, 96(a1)
+; LP64E-NEXT:    fsd fa3, 88(a1)
+; LP64E-NEXT:    fsd fa2, 80(a1)
+; LP64E-NEXT:    fsd fa1, 72(a1)
+; LP64E-NEXT:    fsd fa0, 64(a1)
+; LP64E-NEXT:    fsd ft7, 56(a1)
+; LP64E-NEXT:    fsd ft6, 48(a1)
+; LP64E-NEXT:    fsd ft5, 40(a1)
+; LP64E-NEXT:    fsd ft4, 32(a1)
+; LP64E-NEXT:    fsd ft3, 24(a1)
+; LP64E-NEXT:    fsd ft2, 16(a1)
+; LP64E-NEXT:    fsd ft1, %lo(var+8)(a0)
+; LP64E-NEXT:    fsd ft0, %lo(var)(a0)
+; LP64E-NEXT:    ret
+;
 ; ILP32D-LABEL: callee:
 ; ILP32D:       # %bb.0:
 ; ILP32D-NEXT:    addi sp, sp, -96
@@ -647,6 +719,149 @@ define void @caller() nounwind {
 ; LP64-NEXT:    addi sp, sp, 288
 ; LP64-NEXT:    ret
 ;
+; LP64E-LABEL: caller:
+; LP64E:       # %bb.0:
+; LP64E-NEXT:    addi sp, sp, -280
+; LP64E-NEXT:    sd ra, 272(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    sd s0, 264(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    sd s1, 256(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    lui s0, %hi(var)
+; LP64E-NEXT:    fld ft0, %lo(var)(s0)
+; LP64E-NEXT:    fsd ft0, 248(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, %lo(var+8)(s0)
+; LP64E-NEXT:    fsd ft0, 240(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    addi s1, s0, %lo(var)
+; LP64E-NEXT:    fld ft0, 16(s1)
+; LP64E-NEXT:    fsd ft0, 232(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 24(s1)
+; LP64E-NEXT:    fsd ft0, 224(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 32(s1)
+; LP64E-NEXT:    fsd ft0, 216(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 40(s1)
+; LP64E-NEXT:    fsd ft0, 208(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 48(s1)
+; LP64E-NEXT:    fsd ft0, 200(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 56(s1)
+; LP64E-NEXT:    fsd ft0, 192(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 64(s1)
+; LP64E-NEXT:    fsd ft0, 184(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 72(s1)
+; LP64E-NEXT:    fsd ft0, 176(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 80(s1)
+; LP64E-NEXT:    fsd ft0, 168(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 88(s1)
+; LP64E-NEXT:    fsd ft0, 160(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 96(s1)
+; LP64E-NEXT:    fsd ft0, 152(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 104(s1)
+; LP64E-NEXT:    fsd ft0, 144(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 112(s1)
+; LP64E-NEXT:    fsd ft0, 136(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 120(s1)
+; LP64E-NEXT:    fsd ft0, 128(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 128(s1)
+; LP64E-NEXT:    fsd ft0, 120(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 136(s1)
+; LP64E-NEXT:    fsd ft0, 112(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 144(s1)
+; LP64E-NEXT:    fsd ft0, 104(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 152(s1)
+; LP64E-NEXT:    fsd ft0, 96(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 160(s1)
+; LP64E-NEXT:    fsd ft0, 88(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 168(s1)
+; LP64E-NEXT:    fsd ft0, 80(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 176(s1)
+; LP64E-NEXT:    fsd ft0, 72(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 184(s1)
+; LP64E-NEXT:    fsd ft0, 64(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 192(s1)
+; LP64E-NEXT:    fsd ft0, 56(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 200(s1)
+; LP64E-NEXT:    fsd ft0, 48(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 208(s1)
+; LP64E-NEXT:    fsd ft0, 40(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 216(s1)
+; LP64E-NEXT:    fsd ft0, 32(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 224(s1)
+; LP64E-NEXT:    fsd ft0, 24(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 232(s1)
+; LP64E-NEXT:    fsd ft0, 16(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 240(s1)
+; LP64E-NEXT:    fsd ft0, 8(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    fld ft0, 248(s1)
+; LP64E-NEXT:    fsd ft0, 0(sp) # 8-byte Folded Spill
+; LP64E-NEXT:    call callee@plt
+; LP64E-NEXT:    fld ft0, 0(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 248(s1)
+; LP64E-NEXT:    fld ft0, 8(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 240(s1)
+; LP64E-NEXT:    fld ft0, 16(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 232(s1)
+; LP64E-NEXT:    fld ft0, 24(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 224(s1)
+; LP64E-NEXT:    fld ft0, 32(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 216(s1)
+; LP64E-NEXT:    fld ft0, 40(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 208(s1)
+; LP64E-NEXT:    fld ft0, 48(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 200(s1)
+; LP64E-NEXT:    fld ft0, 56(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 192(s1)
+; LP64E-NEXT:    fld ft0, 64(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 184(s1)
+; LP64E-NEXT:    fld ft0, 72(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 176(s1)
+; LP64E-NEXT:    fld ft0, 80(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 168(s1)
+; LP64E-NEXT:    fld ft0, 88(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 160(s1)
+; LP64E-NEXT:    fld ft0, 96(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 152(s1)
+; LP64E-NEXT:    fld ft0, 104(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 144(s1)
+; LP64E-NEXT:    fld ft0, 112(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 136(s1)
+; LP64E-NEXT:    fld ft0, 120(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 128(s1)
+; LP64E-NEXT:    fld ft0, 128(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 120(s1)
+; LP64E-NEXT:    fld ft0, 136(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 112(s1)
+; LP64E-NEXT:    fld ft0, 144(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 104(s1)
+; LP64E-NEXT:    fld ft0, 152(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 96(s1)
+; LP64E-NEXT:    fld ft0, 160(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 88(s1)
+; LP64E-NEXT:    fld ft0, 168(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 80(s1)
+; LP64E-NEXT:    fld ft0, 176(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 72(s1)
+; LP64E-NEXT:    fld ft0, 184(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 64(s1)
+; LP64E-NEXT:    fld ft0, 192(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 56(s1)
+; LP64E-NEXT:    fld ft0, 200(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 48(s1)
+; LP64E-NEXT:    fld ft0, 208(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 40(s1)
+; LP64E-NEXT:    fld ft0, 216(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 32(s1)
+; LP64E-NEXT:    fld ft0, 224(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 24(s1)
+; LP64E-NEXT:    fld ft0, 232(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, 16(s1)
+; LP64E-NEXT:    fld ft0, 240(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, %lo(var+8)(s0)
+; LP64E-NEXT:    fld ft0, 248(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    fsd ft0, %lo(var)(s0)
+; LP64E-NEXT:    ld ra, 272(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    ld s0, 264(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    ld s1, 256(sp) # 8-byte Folded Reload
+; LP64E-NEXT:    addi sp, sp, 280
+; LP64E-NEXT:    ret
+;
 ; ILP32D-LABEL: caller:
 ; ILP32D:       # %bb.0:
 ; ILP32D-NEXT:    addi sp, sp, -272
diff --git a/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll b/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll
index 6cbac2b0685f..a214d841b360 100644
--- a/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll
+++ b/llvm/test/CodeGen/RISCV/callee-saved-gprs.ll
@@ -1,6 +1,8 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32I-ILP32E
 ; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
 ; RUN: llc -mtriple=riscv32 -mattr=+d -target-abi ilp32f -verify-machineinstrs < %s \
@@ -11,6 +13,8 @@
 ; RUN:   | FileCheck %s -check-prefix=RV32I-WITH-FP
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV64I
+; RUN: llc -mtriple=riscv64 -target-abi lp64e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV64I-LP64E
 ; RUN: llc -mtriple=riscv64 -mattr=+f -target-abi lp64f -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV64I
 ; RUN: llc -mtriple=riscv64 -mattr=+d -target-abi lp64f -verify-machineinstrs < %s \
@@ -136,6 +140,96 @@ define void @callee() nounwind {
 ; RV32I-NEXT:    addi sp, sp, 80
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: callee:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -48
+; RV32I-ILP32E-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s1, 36(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lui a7, %hi(var)
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 32(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var+4)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 28(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var+8)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 24(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, %lo(var+12)(a7)
+; RV32I-ILP32E-NEXT:    sw a0, 20(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    addi a5, a7, %lo(var)
+; RV32I-ILP32E-NEXT:    lw a0, 16(a5)
+; RV32I-ILP32E-NEXT:    sw a0, 16(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 20(a5)
+; RV32I-ILP32E-NEXT:    sw a0, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw t0, 24(a5)
+; RV32I-ILP32E-NEXT:    lw t1, 28(a5)
+; RV32I-ILP32E-NEXT:    lw t2, 32(a5)
+; RV32I-ILP32E-NEXT:    lw t3, 36(a5)
+; RV32I-ILP32E-NEXT:    lw t4, 40(a5)
+; RV32I-ILP32E-NEXT:    lw t5, 44(a5)
+; RV32I-ILP32E-NEXT:    lw t6, 48(a5)
+; RV32I-ILP32E-NEXT:    lw s2, 52(a5)
+; RV32I-ILP32E-NEXT:    lw s3, 56(a5)
+; RV32I-ILP32E-NEXT:    lw s4, 60(a5)
+; RV32I-ILP32E-NEXT:    lw s5, 64(a5)
+; RV32I-ILP32E-NEXT:    lw s6, 68(a5)
+; RV32I-ILP32E-NEXT:    lw s7, 72(a5)
+; RV32I-ILP32E-NEXT:    lw s8, 76(a5)
+; RV32I-ILP32E-NEXT:    lw s9, 80(a5)
+; RV32I-ILP32E-NEXT:    lw s10, 84(a5)
+; RV32I-ILP32E-NEXT:    lw s11, 88(a5)
+; RV32I-ILP32E-NEXT:    lw s0, 92(a5)
+; RV32I-ILP32E-NEXT:    lw s1, 96(a5)
+; RV32I-ILP32E-NEXT:    lw ra, 100(a5)
+; RV32I-ILP32E-NEXT:    lw a6, 104(a5)
+; RV32I-ILP32E-NEXT:    lw a4, 108(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 124(a5)
+; RV32I-ILP32E-NEXT:    lw a1, 120(a5)
+; RV32I-ILP32E-NEXT:    lw a2, 116(a5)
+; RV32I-ILP32E-NEXT:    lw a3, 112(a5)
+; RV32I-ILP32E-NEXT:    sw a0, 124(a5)
+; RV32I-ILP32E-NEXT:    sw a1, 120(a5)
+; RV32I-ILP32E-NEXT:    sw a2, 116(a5)
+; RV32I-ILP32E-NEXT:    sw a3, 112(a5)
+; RV32I-ILP32E-NEXT:    sw a4, 108(a5)
+; RV32I-ILP32E-NEXT:    sw a6, 104(a5)
+; RV32I-ILP32E-NEXT:    sw ra, 100(a5)
+; RV32I-ILP32E-NEXT:    sw s1, 96(a5)
+; RV32I-ILP32E-NEXT:    sw s0, 92(a5)
+; RV32I-ILP32E-NEXT:    sw s11, 88(a5)
+; RV32I-ILP32E-NEXT:    sw s10, 84(a5)
+; RV32I-ILP32E-NEXT:    sw s9, 80(a5)
+; RV32I-ILP32E-NEXT:    sw s8, 76(a5)
+; RV32I-ILP32E-NEXT:    sw s7, 72(a5)
+; RV32I-ILP32E-NEXT:    sw s6, 68(a5)
+; RV32I-ILP32E-NEXT:    sw s5, 64(a5)
+; RV32I-ILP32E-NEXT:    sw s4, 60(a5)
+; RV32I-ILP32E-NEXT:    sw s3, 56(a5)
+; RV32I-ILP32E-NEXT:    sw s2, 52(a5)
+; RV32I-ILP32E-NEXT:    sw t6, 48(a5)
+; RV32I-ILP32E-NEXT:    sw t5, 44(a5)
+; RV32I-ILP32E-NEXT:    sw t4, 40(a5)
+; RV32I-ILP32E-NEXT:    sw t3, 36(a5)
+; RV32I-ILP32E-NEXT:    sw t2, 32(a5)
+; RV32I-ILP32E-NEXT:    sw t1, 28(a5)
+; RV32I-ILP32E-NEXT:    sw t0, 24(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 20(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 16(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 16(a5)
+; RV32I-ILP32E-NEXT:    lw a0, 20(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+12)(a7)
+; RV32I-ILP32E-NEXT:    lw a0, 24(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+8)(a7)
+; RV32I-ILP32E-NEXT:    lw a0, 28(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+4)(a7)
+; RV32I-ILP32E-NEXT:    lw a0, 32(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var)(a7)
+; RV32I-ILP32E-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s1, 36(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 48
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV32I-WITH-FP-LABEL: callee:
 ; RV32I-WITH-FP:       # %bb.0:
 ; RV32I-WITH-FP-NEXT:    addi sp, sp, -80
@@ -359,6 +453,96 @@ define void @callee() nounwind {
 ; RV64I-NEXT:    addi sp, sp, 160
 ; RV64I-NEXT:    ret
 ;
+; RV64I-LP64E-LABEL: callee:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -80
+; RV64I-LP64E-NEXT:    sd ra, 72(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 64(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s1, 56(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lui a7, %hi(var)
+; RV64I-LP64E-NEXT:    lw a0, %lo(var)(a7)
+; RV64I-LP64E-NEXT:    sd a0, 48(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, %lo(var+4)(a7)
+; RV64I-LP64E-NEXT:    sd a0, 40(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, %lo(var+8)(a7)
+; RV64I-LP64E-NEXT:    sd a0, 32(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, %lo(var+12)(a7)
+; RV64I-LP64E-NEXT:    sd a0, 24(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    addi a5, a7, %lo(var)
+; RV64I-LP64E-NEXT:    lw a0, 16(a5)
+; RV64I-LP64E-NEXT:    sd a0, 16(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 20(a5)
+; RV64I-LP64E-NEXT:    sd a0, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw t0, 24(a5)
+; RV64I-LP64E-NEXT:    lw t1, 28(a5)
+; RV64I-LP64E-NEXT:    lw t2, 32(a5)
+; RV64I-LP64E-NEXT:    lw t3, 36(a5)
+; RV64I-LP64E-NEXT:    lw t4, 40(a5)
+; RV64I-LP64E-NEXT:    lw t5, 44(a5)
+; RV64I-LP64E-NEXT:    lw t6, 48(a5)
+; RV64I-LP64E-NEXT:    lw s2, 52(a5)
+; RV64I-LP64E-NEXT:    lw s3, 56(a5)
+; RV64I-LP64E-NEXT:    lw s4, 60(a5)
+; RV64I-LP64E-NEXT:    lw s5, 64(a5)
+; RV64I-LP64E-NEXT:    lw s6, 68(a5)
+; RV64I-LP64E-NEXT:    lw s7, 72(a5)
+; RV64I-LP64E-NEXT:    lw s8, 76(a5)
+; RV64I-LP64E-NEXT:    lw s9, 80(a5)
+; RV64I-LP64E-NEXT:    lw s10, 84(a5)
+; RV64I-LP64E-NEXT:    lw s11, 88(a5)
+; RV64I-LP64E-NEXT:    lw s0, 92(a5)
+; RV64I-LP64E-NEXT:    lw s1, 96(a5)
+; RV64I-LP64E-NEXT:    lw ra, 100(a5)
+; RV64I-LP64E-NEXT:    lw a6, 104(a5)
+; RV64I-LP64E-NEXT:    lw a4, 108(a5)
+; RV64I-LP64E-NEXT:    lw a0, 124(a5)
+; RV64I-LP64E-NEXT:    lw a1, 120(a5)
+; RV64I-LP64E-NEXT:    lw a2, 116(a5)
+; RV64I-LP64E-NEXT:    lw a3, 112(a5)
+; RV64I-LP64E-NEXT:    sw a0, 124(a5)
+; RV64I-LP64E-NEXT:    sw a1, 120(a5)
+; RV64I-LP64E-NEXT:    sw a2, 116(a5)
+; RV64I-LP64E-NEXT:    sw a3, 112(a5)
+; RV64I-LP64E-NEXT:    sw a4, 108(a5)
+; RV64I-LP64E-NEXT:    sw a6, 104(a5)
+; RV64I-LP64E-NEXT:    sw ra, 100(a5)
+; RV64I-LP64E-NEXT:    sw s1, 96(a5)
+; RV64I-LP64E-NEXT:    sw s0, 92(a5)
+; RV64I-LP64E-NEXT:    sw s11, 88(a5)
+; RV64I-LP64E-NEXT:    sw s10, 84(a5)
+; RV64I-LP64E-NEXT:    sw s9, 80(a5)
+; RV64I-LP64E-NEXT:    sw s8, 76(a5)
+; RV64I-LP64E-NEXT:    sw s7, 72(a5)
+; RV64I-LP64E-NEXT:    sw s6, 68(a5)
+; RV64I-LP64E-NEXT:    sw s5, 64(a5)
+; RV64I-LP64E-NEXT:    sw s4, 60(a5)
+; RV64I-LP64E-NEXT:    sw s3, 56(a5)
+; RV64I-LP64E-NEXT:    sw s2, 52(a5)
+; RV64I-LP64E-NEXT:    sw t6, 48(a5)
+; RV64I-LP64E-NEXT:    sw t5, 44(a5)
+; RV64I-LP64E-NEXT:    sw t4, 40(a5)
+; RV64I-LP64E-NEXT:    sw t3, 36(a5)
+; RV64I-LP64E-NEXT:    sw t2, 32(a5)
+; RV64I-LP64E-NEXT:    sw t1, 28(a5)
+; RV64I-LP64E-NEXT:    sw t0, 24(a5)
+; RV64I-LP64E-NEXT:    ld a0, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 20(a5)
+; RV64I-LP64E-NEXT:    ld a0, 16(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 16(a5)
+; RV64I-LP64E-NEXT:    ld a0, 24(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var+12)(a7)
+; RV64I-LP64E-NEXT:    ld a0, 32(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var+8)(a7)
+; RV64I-LP64E-NEXT:    ld a0, 40(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var+4)(a7)
+; RV64I-LP64E-NEXT:    ld a0, 48(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var)(a7)
+; RV64I-LP64E-NEXT:    ld ra, 72(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 64(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s1, 56(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 80
+; RV64I-LP64E-NEXT:    ret
+;
 ; RV64I-WITH-FP-LABEL: callee:
 ; RV64I-WITH-FP:       # %bb.0:
 ; RV64I-WITH-FP-NEXT:    addi sp, sp, -160
@@ -623,6 +807,148 @@ define void @caller() nounwind {
 ; RV32I-NEXT:    addi sp, sp, 144
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -136
+; RV32I-ILP32E-NEXT:    sw ra, 132(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 128(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s1, 124(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lui a0, %hi(var)
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 120(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var+4)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 116(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var+8)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 112(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a1, %lo(var+12)(a0)
+; RV32I-ILP32E-NEXT:    sw a1, 108(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    addi s1, a0, %lo(var)
+; RV32I-ILP32E-NEXT:    lw a0, 16(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 104(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 20(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 100(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 24(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 96(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 28(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 92(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 32(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 88(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 36(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 84(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 40(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 80(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 44(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 76(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 48(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 72(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 52(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 68(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 56(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 64(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 60(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 60(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 64(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 56(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 68(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 52(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 72(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 48(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 76(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 44(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 80(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 40(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 84(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 36(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 88(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 32(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 92(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 28(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 96(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 24(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 100(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 20(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 104(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 16(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 108(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 112(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 8(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 116(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw a0, 120(s1)
+; RV32I-ILP32E-NEXT:    sw a0, 0(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    lw s0, 124(s1)
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    sw s0, 124(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 0(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 120(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 116(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 8(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 112(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 108(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 16(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 104(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 20(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 100(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 24(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 96(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 28(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 92(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 32(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 88(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 36(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 84(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 40(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 80(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 44(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 76(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 48(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 72(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 52(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 68(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 56(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 64(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 60(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 60(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 64(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 56(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 68(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 52(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 72(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 48(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 76(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 44(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 80(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 40(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 84(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 36(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 88(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 32(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 92(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 28(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 96(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 24(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 100(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 20(s1)
+; RV32I-ILP32E-NEXT:    lw a0, 104(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, 16(s1)
+; RV32I-ILP32E-NEXT:    lui a1, %hi(var)
+; RV32I-ILP32E-NEXT:    lw a0, 108(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+12)(a1)
+; RV32I-ILP32E-NEXT:    lw a0, 112(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+8)(a1)
+; RV32I-ILP32E-NEXT:    lw a0, 116(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var+4)(a1)
+; RV32I-ILP32E-NEXT:    lw a0, 120(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    sw a0, %lo(var)(a1)
+; RV32I-ILP32E-NEXT:    lw ra, 132(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 128(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s1, 124(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 136
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV32I-WITH-FP-LABEL: caller:
 ; RV32I-WITH-FP:       # %bb.0:
 ; RV32I-WITH-FP-NEXT:    addi sp, sp, -144
@@ -912,6 +1238,148 @@ define void @caller() nounwind {
 ; RV64I-NEXT:    addi sp, sp, 288
 ; RV64I-NEXT:    ret
 ;
+; RV64I-LP64E-LABEL: caller:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -272
+; RV64I-LP64E-NEXT:    sd ra, 264(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 256(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s1, 248(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lui a0, %hi(var)
+; RV64I-LP64E-NEXT:    lw a1, %lo(var)(a0)
+; RV64I-LP64E-NEXT:    sd a1, 240(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a1, %lo(var+4)(a0)
+; RV64I-LP64E-NEXT:    sd a1, 232(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a1, %lo(var+8)(a0)
+; RV64I-LP64E-NEXT:    sd a1, 224(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a1, %lo(var+12)(a0)
+; RV64I-LP64E-NEXT:    sd a1, 216(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    addi s1, a0, %lo(var)
+; RV64I-LP64E-NEXT:    lw a0, 16(s1)
+; RV64I-LP64E-NEXT:    sd a0, 208(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 20(s1)
+; RV64I-LP64E-NEXT:    sd a0, 200(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 24(s1)
+; RV64I-LP64E-NEXT:    sd a0, 192(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 28(s1)
+; RV64I-LP64E-NEXT:    sd a0, 184(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 32(s1)
+; RV64I-LP64E-NEXT:    sd a0, 176(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 36(s1)
+; RV64I-LP64E-NEXT:    sd a0, 168(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 40(s1)
+; RV64I-LP64E-NEXT:    sd a0, 160(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 44(s1)
+; RV64I-LP64E-NEXT:    sd a0, 152(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 48(s1)
+; RV64I-LP64E-NEXT:    sd a0, 144(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 52(s1)
+; RV64I-LP64E-NEXT:    sd a0, 136(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 56(s1)
+; RV64I-LP64E-NEXT:    sd a0, 128(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 60(s1)
+; RV64I-LP64E-NEXT:    sd a0, 120(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 64(s1)
+; RV64I-LP64E-NEXT:    sd a0, 112(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 68(s1)
+; RV64I-LP64E-NEXT:    sd a0, 104(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 72(s1)
+; RV64I-LP64E-NEXT:    sd a0, 96(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 76(s1)
+; RV64I-LP64E-NEXT:    sd a0, 88(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 80(s1)
+; RV64I-LP64E-NEXT:    sd a0, 80(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 84(s1)
+; RV64I-LP64E-NEXT:    sd a0, 72(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 88(s1)
+; RV64I-LP64E-NEXT:    sd a0, 64(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 92(s1)
+; RV64I-LP64E-NEXT:    sd a0, 56(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 96(s1)
+; RV64I-LP64E-NEXT:    sd a0, 48(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 100(s1)
+; RV64I-LP64E-NEXT:    sd a0, 40(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 104(s1)
+; RV64I-LP64E-NEXT:    sd a0, 32(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 108(s1)
+; RV64I-LP64E-NEXT:    sd a0, 24(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 112(s1)
+; RV64I-LP64E-NEXT:    sd a0, 16(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 116(s1)
+; RV64I-LP64E-NEXT:    sd a0, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw a0, 120(s1)
+; RV64I-LP64E-NEXT:    sd a0, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    lw s0, 124(s1)
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    sw s0, 124(s1)
+; RV64I-LP64E-NEXT:    ld a0, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 120(s1)
+; RV64I-LP64E-NEXT:    ld a0, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 116(s1)
+; RV64I-LP64E-NEXT:    ld a0, 16(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 112(s1)
+; RV64I-LP64E-NEXT:    ld a0, 24(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 108(s1)
+; RV64I-LP64E-NEXT:    ld a0, 32(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 104(s1)
+; RV64I-LP64E-NEXT:    ld a0, 40(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 100(s1)
+; RV64I-LP64E-NEXT:    ld a0, 48(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 96(s1)
+; RV64I-LP64E-NEXT:    ld a0, 56(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 92(s1)
+; RV64I-LP64E-NEXT:    ld a0, 64(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 88(s1)
+; RV64I-LP64E-NEXT:    ld a0, 72(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 84(s1)
+; RV64I-LP64E-NEXT:    ld a0, 80(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 80(s1)
+; RV64I-LP64E-NEXT:    ld a0, 88(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 76(s1)
+; RV64I-LP64E-NEXT:    ld a0, 96(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 72(s1)
+; RV64I-LP64E-NEXT:    ld a0, 104(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 68(s1)
+; RV64I-LP64E-NEXT:    ld a0, 112(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 64(s1)
+; RV64I-LP64E-NEXT:    ld a0, 120(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 60(s1)
+; RV64I-LP64E-NEXT:    ld a0, 128(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 56(s1)
+; RV64I-LP64E-NEXT:    ld a0, 136(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 52(s1)
+; RV64I-LP64E-NEXT:    ld a0, 144(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 48(s1)
+; RV64I-LP64E-NEXT:    ld a0, 152(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 44(s1)
+; RV64I-LP64E-NEXT:    ld a0, 160(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 40(s1)
+; RV64I-LP64E-NEXT:    ld a0, 168(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 36(s1)
+; RV64I-LP64E-NEXT:    ld a0, 176(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 32(s1)
+; RV64I-LP64E-NEXT:    ld a0, 184(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 28(s1)
+; RV64I-LP64E-NEXT:    ld a0, 192(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 24(s1)
+; RV64I-LP64E-NEXT:    ld a0, 200(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 20(s1)
+; RV64I-LP64E-NEXT:    ld a0, 208(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, 16(s1)
+; RV64I-LP64E-NEXT:    lui a1, %hi(var)
+; RV64I-LP64E-NEXT:    ld a0, 216(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var+12)(a1)
+; RV64I-LP64E-NEXT:    ld a0, 224(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var+8)(a1)
+; RV64I-LP64E-NEXT:    ld a0, 232(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var+4)(a1)
+; RV64I-LP64E-NEXT:    ld a0, 240(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    sw a0, %lo(var)(a1)
+; RV64I-LP64E-NEXT:    ld ra, 264(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 256(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s1, 248(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 272
+; RV64I-LP64E-NEXT:    ret
+;
 ; RV64I-WITH-FP-LABEL: caller:
 ; RV64I-WITH-FP:       # %bb.0:
 ; RV64I-WITH-FP-NEXT:    addi sp, sp, -288
diff --git a/llvm/test/CodeGen/RISCV/calling-conv-ilp32e.ll b/llvm/test/CodeGen/RISCV/calling-conv-ilp32e.ll
new file mode 100644
index 000000000000..3579c760896c
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/calling-conv-ilp32e.ll
@@ -0,0 +1,2556 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-FPELIM %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -frame-pointer=all \
+; RUN:   -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-WITHFP %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -mattr=+save-restore -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-FPELIM-SAVE-RESTORE %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -mattr=+save-restore -frame-pointer=all \
+; RUN:   -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-WITHFP-SAVE-RESTORE %s
+
+; As well as calling convention details, we check that ra and fp are
+; consistently stored to fp-4 and fp-8.
+
+; Any tests that would have identical output for some combination of the ilp32*
+; ABIs belong in calling-conv-*-common.ll. This file contains tests that will
+; have different output across those ABIs. i.e. where some arguments would be
+; passed according to the floating point ABI, or where the stack is aligned to
+; a different boundary.
+
+define i32 @callee_float_in_regs(i32 %a, float %b) {
+; ILP32E-FPELIM-LABEL: callee_float_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-FPELIM-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    mv s0, a0
+; ILP32E-FPELIM-NEXT:    mv a0, a1
+; ILP32E-FPELIM-NEXT:    call __fixsfsi@plt
+; ILP32E-FPELIM-NEXT:    add a0, s0, a0
+; ILP32E-FPELIM-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 8
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_float_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    mv s1, a0
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    call __fixsfsi@plt
+; ILP32E-WITHFP-NEXT:    add a0, s1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 12
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_float_in_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv s0, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call __fixsfsi@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, s0, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_float_in_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv s1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call __fixsfsi@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, s1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_2
+  %b_fptosi = fptosi float %b to i32
+  %1 = add i32 %a, %b_fptosi
+  ret i32 %1
+}
+
+define i32 @caller_float_in_regs() {
+; ILP32E-FPELIM-LABEL: caller_float_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    lui a1, 262144
+; ILP32E-FPELIM-NEXT:    call callee_float_in_regs@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_float_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    lui a1, 262144
+; ILP32E-WITHFP-NEXT:    call callee_float_in_regs@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_float_in_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a1, 262144
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_float_in_regs@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_float_in_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a1, 262144
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_float_in_regs@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_float_in_regs(i32 1, float 2.0)
+  ret i32 %1
+}
+
+define i32 @callee_float_on_stack(i64 %a, i64 %b, i64 %c, i64 %d, float %e) {
+; ILP32E-FPELIM-LABEL: callee_float_on_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 0(sp)
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_float_on_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a0, 8(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 0(s0)
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_float_on_stack:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a1, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_float_on_stack:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 8(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a1, 0(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = trunc i64 %d to i32
+  %2 = bitcast float %e to i32
+  %3 = add i32 %1, %2
+  ret i32 %3
+}
+
+define i32 @caller_float_on_stack() {
+; ILP32E-FPELIM-LABEL: caller_float_on_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-FPELIM-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    lui a0, 264704
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a1, 4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a2, 2
+; ILP32E-FPELIM-NEXT:    li a4, 3
+; ILP32E-FPELIM-NEXT:    sw a1, 0(sp)
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    li a3, 0
+; ILP32E-FPELIM-NEXT:    li a5, 0
+; ILP32E-FPELIM-NEXT:    call callee_float_on_stack@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 16
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_float_on_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -20
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 20
+; ILP32E-WITHFP-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 20
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a0, 264704
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a1, 4
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a2, 2
+; ILP32E-WITHFP-NEXT:    li a4, 3
+; ILP32E-WITHFP-NEXT:    sw a1, 0(sp)
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    li a3, 0
+; ILP32E-WITHFP-NEXT:    li a5, 0
+; ILP32E-WITHFP-NEXT:    call callee_float_on_stack@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 20
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_float_on_stack:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -12
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 264704
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a2, 2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a4, 3
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a3, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a5, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_float_on_stack@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 12
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_float_on_stack:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 20
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 20
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 264704
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 4(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a2, 2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a4, 3
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, 0(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a3, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a5, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_float_on_stack@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_float_on_stack(i64 1, i64 2, i64 3, i64 4, float 5.0)
+  ret i32 %1
+}
+
+define float @callee_tiny_scalar_ret() {
+; ILP32E-FPELIM-LABEL: callee_tiny_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lui a0, 260096
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_tiny_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a0, 260096
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_tiny_scalar_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 260096
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_tiny_scalar_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 260096
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  ret float 1.0
+}
+
+define i32 @caller_tiny_scalar_ret() {
+; ILP32E-FPELIM-LABEL: caller_tiny_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    call callee_tiny_scalar_ret@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_tiny_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    call callee_tiny_scalar_ret@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_tiny_scalar_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_tiny_scalar_ret@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_tiny_scalar_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_tiny_scalar_ret@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call float @callee_tiny_scalar_ret()
+  %2 = bitcast float %1 to i32
+  ret i32 %2
+}
+
+; Check that on RV32 ilp32e, double is passed in a pair of registers. Unlike
+; the convention for varargs, this need not be an aligned pair.
+
+define i32 @callee_double_in_regs(i32 %a, double %b) {
+; ILP32E-FPELIM-LABEL: callee_double_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-FPELIM-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    mv s0, a0
+; ILP32E-FPELIM-NEXT:    mv a0, a1
+; ILP32E-FPELIM-NEXT:    mv a1, a2
+; ILP32E-FPELIM-NEXT:    call __fixdfsi@plt
+; ILP32E-FPELIM-NEXT:    add a0, s0, a0
+; ILP32E-FPELIM-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 8
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_double_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    mv s1, a0
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    mv a1, a2
+; ILP32E-WITHFP-NEXT:    call __fixdfsi@plt
+; ILP32E-WITHFP-NEXT:    add a0, s1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 12
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_double_in_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv s0, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a1, a2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call __fixdfsi@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, s0, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_double_in_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv s1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a1, a2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call __fixdfsi@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, s1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_2
+  %b_fptosi = fptosi double %b to i32
+  %1 = add i32 %a, %b_fptosi
+  ret i32 %1
+}
+
+define i32 @caller_double_in_regs() {
+; ILP32E-FPELIM-LABEL: caller_double_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    lui a2, 262144
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    call callee_double_in_regs@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_double_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    lui a2, 262144
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call callee_double_in_regs@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_double_in_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a2, 262144
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_double_in_regs@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_double_in_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a2, 262144
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_double_in_regs@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_double_in_regs(i32 1, double 2.0)
+  ret i32 %1
+}
+
+; Check 2x*xlen values are aligned appropriately when passed on the stack
+; Must keep define on a single line due to an update_llc_test_checks.py limitation
+define i32 @callee_aligned_stack(i32 %a, i32 %b, fp128 %c, i32 %d, i32 %e, i64 %f, i32 %g, i32 %h, double %i, i32 %j, [2 x i32] %k) {
+; The double should be 8-byte aligned on the stack, but the two-element array
+; should only be 4-byte aligned
+; ILP32E-FPELIM-LABEL: callee_aligned_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a0, 0(a2)
+; ILP32E-FPELIM-NEXT:    lw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a2, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a3, 8(sp)
+; ILP32E-FPELIM-NEXT:    lw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    lw a5, 20(sp)
+; ILP32E-FPELIM-NEXT:    add a0, a0, a2
+; ILP32E-FPELIM-NEXT:    add a1, a3, a1
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    add a4, a5, a4
+; ILP32E-FPELIM-NEXT:    add a0, a0, a4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_aligned_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a2)
+; ILP32E-WITHFP-NEXT:    lw a1, 12(s0)
+; ILP32E-WITHFP-NEXT:    lw a2, 4(s0)
+; ILP32E-WITHFP-NEXT:    lw a3, 8(s0)
+; ILP32E-WITHFP-NEXT:    lw a4, 24(s0)
+; ILP32E-WITHFP-NEXT:    lw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    add a0, a0, a2
+; ILP32E-WITHFP-NEXT:    add a1, a3, a1
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    add a4, a5, a4
+; ILP32E-WITHFP-NEXT:    add a0, a0, a4
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_aligned_stack:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 0(a2)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a1, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a2, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a3, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a4, 24(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a5, 20(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a1, a3, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a4, a5, a4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_aligned_stack:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 0(a2)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a1, 12(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a2, 4(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a3, 8(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a4, 24(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a5, 20(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a1, a3, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a4, a5, a4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = bitcast fp128 %c to i128
+  %2 = trunc i128 %1 to i32
+  %3 = add i32 %2, %g
+  %4 = add i32 %3, %h
+  %5 = bitcast double %i to i64
+  %6 = trunc i64 %5 to i32
+  %7 = add i32 %4, %6
+  %8 = add i32 %7, %j
+  %9 = extractvalue [2 x i32] %k, 0
+  %10 = add i32 %8, %9
+  ret i32 %10
+}
+
+define void @caller_aligned_stack() {
+; The double should be 8-byte aligned on the stack, but the two-element array
+; should only be 4-byte aligned
+; ILP32E-FPELIM-LABEL: caller_aligned_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-FPELIM-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    li a0, 18
+; ILP32E-FPELIM-NEXT:    sw a0, 28(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 17
+; ILP32E-FPELIM-NEXT:    sw a0, 24(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 16
+; ILP32E-FPELIM-NEXT:    sw a0, 20(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 262236
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 655
+; ILP32E-FPELIM-NEXT:    sw a0, 16(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 377487
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 1475
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 15
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 14
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 4
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 262153
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 491
+; ILP32E-FPELIM-NEXT:    sw a0, 44(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 545260
+; ILP32E-FPELIM-NEXT:    addi a0, a0, -1967
+; ILP32E-FPELIM-NEXT:    sw a0, 40(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 964690
+; ILP32E-FPELIM-NEXT:    addi a0, a0, -328
+; ILP32E-FPELIM-NEXT:    sw a0, 36(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 335544
+; ILP32E-FPELIM-NEXT:    addi a6, a0, 1311
+; ILP32E-FPELIM-NEXT:    lui a0, 688509
+; ILP32E-FPELIM-NEXT:    addi a5, a0, -2048
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 11
+; ILP32E-FPELIM-NEXT:    addi a2, sp, 32
+; ILP32E-FPELIM-NEXT:    li a3, 12
+; ILP32E-FPELIM-NEXT:    li a4, 13
+; ILP32E-FPELIM-NEXT:    sw a6, 32(sp)
+; ILP32E-FPELIM-NEXT:    call callee_aligned_stack@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -64
+; ILP32E-FPELIM-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 64
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_aligned_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-WITHFP-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    li a0, 18
+; ILP32E-WITHFP-NEXT:    sw a0, 28(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 17
+; ILP32E-WITHFP-NEXT:    sw a0, 24(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 16
+; ILP32E-WITHFP-NEXT:    sw a0, 20(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262236
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 655
+; ILP32E-WITHFP-NEXT:    sw a0, 16(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 377487
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 1475
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 15
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 14
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 4
+; ILP32E-WITHFP-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262153
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 491
+; ILP32E-WITHFP-NEXT:    sw a0, 44(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 545260
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -1967
+; ILP32E-WITHFP-NEXT:    sw a0, 40(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 964690
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -328
+; ILP32E-WITHFP-NEXT:    sw a0, 36(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 335544
+; ILP32E-WITHFP-NEXT:    addi a6, a0, 1311
+; ILP32E-WITHFP-NEXT:    lui a0, 688509
+; ILP32E-WITHFP-NEXT:    addi a5, a0, -2048
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 11
+; ILP32E-WITHFP-NEXT:    addi a2, sp, 32
+; ILP32E-WITHFP-NEXT:    li a3, 12
+; ILP32E-WITHFP-NEXT:    li a4, 13
+; ILP32E-WITHFP-NEXT:    sw a6, 32(sp)
+; ILP32E-WITHFP-NEXT:    call callee_aligned_stack@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -64
+; ILP32E-WITHFP-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 64
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_aligned_stack:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -48
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 56
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi s0, sp, 56
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 18
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 28(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 17
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 24(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 20(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 262236
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, a0, 655
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 16(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 377487
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, a0, 1475
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 15
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 14
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 262153
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, a0, 491
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 44(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 545260
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, a0, -1967
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 40(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 964690
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, a0, -328
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 36(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 335544
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a6, a0, 1311
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 688509
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a5, a0, -2048
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 11
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a2, sp, 32
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a3, 12
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a4, 13
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a6, 32(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_aligned_stack@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, s0, -56
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 48
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_aligned_stack:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 56
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 56
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 18
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 28(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 17
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 24(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 20(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 262236
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, a0, 655
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 16(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 377487
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, a0, 1475
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 15
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 14
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 262153
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, a0, 491
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 44(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 545260
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, a0, -1967
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 40(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 964690
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, a0, -328
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 36(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 335544
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a6, a0, 1311
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 688509
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a5, a0, -2048
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 11
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a2, sp, 32
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a3, 12
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a4, 13
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a6, 32(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_aligned_stack@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, s0, -56
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_aligned_stack(i32 1, i32 11,
+    fp128 0xLEB851EB851EB851F400091EB851EB851, i32 12, i32 13,
+    i64 20000000000, i32 14, i32 15, double 2.720000e+00, i32 16,
+    [2 x i32] [i32 17, i32 18])
+  ret void
+}
+
+define double @callee_small_scalar_ret() {
+; ILP32E-FPELIM-LABEL: callee_small_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lui a1, 261888
+; ILP32E-FPELIM-NEXT:    li a0, 0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_small_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a1, 261888
+; ILP32E-WITHFP-NEXT:    li a0, 0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_small_scalar_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a1, 261888
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_small_scalar_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a1, 261888
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  ret double 1.0
+}
+
+define i64 @caller_small_scalar_ret() {
+; ILP32E-FPELIM-LABEL: caller_small_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    call callee_small_scalar_ret@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_small_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    call callee_small_scalar_ret@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_small_scalar_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_small_scalar_ret@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_small_scalar_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_small_scalar_ret@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call double @callee_small_scalar_ret()
+  %2 = bitcast double %1 to i64
+  ret i64 %2
+}
+
+; Check that on RV32, i64 is passed in a pair of registers. Unlike
+; the convention for varargs, this need not be an aligned pair.
+
+define i32 @callee_i64_in_regs(i32 %a, i64 %b) {
+; ILP32E-FPELIM-LABEL: callee_i64_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_i64_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_i64_in_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_i64_in_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %b_trunc = trunc i64 %b to i32
+  %1 = add i32 %a, %b_trunc
+  ret i32 %1
+}
+
+define i32 @caller_i64_in_regs() {
+; ILP32E-FPELIM-LABEL: caller_i64_in_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    li a2, 0
+; ILP32E-FPELIM-NEXT:    call callee_i64_in_regs@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_i64_in_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    li a2, 0
+; ILP32E-WITHFP-NEXT:    call callee_i64_in_regs@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_i64_in_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a2, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_i64_in_regs@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_i64_in_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a2, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_i64_in_regs@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_i64_in_regs(i32 1, i64 2)
+  ret i32 %1
+}
+
+; Check that the stack is used once the GPRs are exhausted
+
+define i32 @callee_many_scalars(i8 %a, i16 %b, i32 %c, i64 %d, i32 %e, i32 %f, i64 %g, i32 %h) {
+; ILP32E-FPELIM-LABEL: callee_many_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a6, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a7, 0(sp)
+; ILP32E-FPELIM-NEXT:    lw t0, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw t1, 8(sp)
+; ILP32E-FPELIM-NEXT:    andi a0, a0, 255
+; ILP32E-FPELIM-NEXT:    slli a1, a1, 16
+; ILP32E-FPELIM-NEXT:    srli a1, a1, 16
+; ILP32E-FPELIM-NEXT:    add a0, a0, a2
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    xor a1, a4, t1
+; ILP32E-FPELIM-NEXT:    xor a2, a3, t0
+; ILP32E-FPELIM-NEXT:    or a1, a2, a1
+; ILP32E-FPELIM-NEXT:    seqz a1, a1
+; ILP32E-FPELIM-NEXT:    add a0, a0, a5
+; ILP32E-FPELIM-NEXT:    add a0, a0, a7
+; ILP32E-FPELIM-NEXT:    add a0, a0, a6
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_many_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a6, 12(s0)
+; ILP32E-WITHFP-NEXT:    lw a7, 0(s0)
+; ILP32E-WITHFP-NEXT:    lw t0, 4(s0)
+; ILP32E-WITHFP-NEXT:    lw t1, 8(s0)
+; ILP32E-WITHFP-NEXT:    andi a0, a0, 255
+; ILP32E-WITHFP-NEXT:    slli a1, a1, 16
+; ILP32E-WITHFP-NEXT:    srli a1, a1, 16
+; ILP32E-WITHFP-NEXT:    add a0, a0, a2
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    xor a1, a4, t1
+; ILP32E-WITHFP-NEXT:    xor a2, a3, t0
+; ILP32E-WITHFP-NEXT:    or a1, a2, a1
+; ILP32E-WITHFP-NEXT:    seqz a1, a1
+; ILP32E-WITHFP-NEXT:    add a0, a0, a5
+; ILP32E-WITHFP-NEXT:    add a0, a0, a7
+; ILP32E-WITHFP-NEXT:    add a0, a0, a6
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_many_scalars:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a6, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a7, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw t0, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw t1, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    andi a0, a0, 255
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    slli a1, a1, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    srli a1, a1, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a1, a4, t1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a2, a3, t0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    or a1, a2, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    seqz a1, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a5
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a7
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a6
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_many_scalars:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a6, 12(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a7, 0(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw t0, 4(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw t1, 8(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    andi a0, a0, 255
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    slli a1, a1, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    srli a1, a1, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a1, a4, t1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a2, a3, t0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    or a1, a2, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    seqz a1, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a5
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a7
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a6
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %a_ext = zext i8 %a to i32
+  %b_ext = zext i16 %b to i32
+  %1 = add i32 %a_ext, %b_ext
+  %2 = add i32 %1, %c
+  %3 = icmp eq i64 %d, %g
+  %4 = zext i1 %3 to i32
+  %5 = add i32 %4, %2
+  %6 = add i32 %5, %e
+  %7 = add i32 %6, %f
+  %8 = add i32 %7, %h
+  ret i32 %8
+}
+
+define i32 @caller_many_scalars() {
+; ILP32E-FPELIM-LABEL: caller_many_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -20
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 20
+; ILP32E-FPELIM-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 8
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 8(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 7
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a4, 6
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    li a2, 3
+; ILP32E-FPELIM-NEXT:    li a3, 4
+; ILP32E-FPELIM-NEXT:    li a5, 5
+; ILP32E-FPELIM-NEXT:    sw a4, 0(sp)
+; ILP32E-FPELIM-NEXT:    li a4, 0
+; ILP32E-FPELIM-NEXT:    call callee_many_scalars@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 20
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_many_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 8
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 8(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 7
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a4, 6
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    li a2, 3
+; ILP32E-WITHFP-NEXT:    li a3, 4
+; ILP32E-WITHFP-NEXT:    li a5, 5
+; ILP32E-WITHFP-NEXT:    sw a4, 0(sp)
+; ILP32E-WITHFP-NEXT:    li a4, 0
+; ILP32E-WITHFP-NEXT:    call callee_many_scalars@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 24
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_many_scalars:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 20
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 7
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a4, 6
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a2, 3
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a3, 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a5, 5
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a4, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a4, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_many_scalars@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_many_scalars:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 8(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 7
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a4, 6
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a2, 3
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a3, 4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a5, 5
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a4, 0(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a4, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_many_scalars@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_many_scalars(i8 1, i16 2, i32 3, i64 4, i32 5, i32 6, i64 7, i32 8)
+  ret i32 %1
+}
+
+; Check that i128 and fp128 are passed indirectly
+
+define i32 @callee_large_scalars(i128 %a, fp128 %b) {
+; ILP32E-FPELIM-LABEL: callee_large_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a2, 0(a1)
+; ILP32E-FPELIM-NEXT:    lw a3, 0(a0)
+; ILP32E-FPELIM-NEXT:    lw a4, 4(a1)
+; ILP32E-FPELIM-NEXT:    lw a5, 12(a1)
+; ILP32E-FPELIM-NEXT:    lw a6, 12(a0)
+; ILP32E-FPELIM-NEXT:    lw a7, 4(a0)
+; ILP32E-FPELIM-NEXT:    lw a1, 8(a1)
+; ILP32E-FPELIM-NEXT:    lw a0, 8(a0)
+; ILP32E-FPELIM-NEXT:    xor a5, a6, a5
+; ILP32E-FPELIM-NEXT:    xor a4, a7, a4
+; ILP32E-FPELIM-NEXT:    or a4, a4, a5
+; ILP32E-FPELIM-NEXT:    xor a0, a0, a1
+; ILP32E-FPELIM-NEXT:    xor a2, a3, a2
+; ILP32E-FPELIM-NEXT:    or a0, a2, a0
+; ILP32E-FPELIM-NEXT:    or a0, a0, a4
+; ILP32E-FPELIM-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a2, 0(a1)
+; ILP32E-WITHFP-NEXT:    lw a3, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw a4, 4(a1)
+; ILP32E-WITHFP-NEXT:    lw a5, 12(a1)
+; ILP32E-WITHFP-NEXT:    lw a6, 12(a0)
+; ILP32E-WITHFP-NEXT:    lw a7, 4(a0)
+; ILP32E-WITHFP-NEXT:    lw a1, 8(a1)
+; ILP32E-WITHFP-NEXT:    lw a0, 8(a0)
+; ILP32E-WITHFP-NEXT:    xor a5, a6, a5
+; ILP32E-WITHFP-NEXT:    xor a4, a7, a4
+; ILP32E-WITHFP-NEXT:    or a4, a4, a5
+; ILP32E-WITHFP-NEXT:    xor a0, a0, a1
+; ILP32E-WITHFP-NEXT:    xor a2, a3, a2
+; ILP32E-WITHFP-NEXT:    or a0, a2, a0
+; ILP32E-WITHFP-NEXT:    or a0, a0, a4
+; ILP32E-WITHFP-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_large_scalars:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a2, 0(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a3, 0(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a4, 4(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a5, 12(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a6, 12(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a7, 4(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a1, 8(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 8(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a5, a6, a5
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a4, a7, a4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    or a4, a4, a5
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a0, a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a2, a3, a2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    or a0, a2, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    or a0, a0, a4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_large_scalars:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a2, 0(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a3, 0(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a4, 4(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a5, 12(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a6, 12(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a7, 4(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a1, 8(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 8(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a5, a6, a5
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a4, a7, a4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    or a4, a4, a5
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a0, a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a2, a3, a2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    or a0, a2, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    or a0, a0, a4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %b_bitcast = bitcast fp128 %b to i128
+  %1 = icmp eq i128 %a, %b_bitcast
+  %2 = zext i1 %1 to i32
+  ret i32 %2
+}
+
+define i32 @caller_large_scalars() {
+; ILP32E-FPELIM-LABEL: caller_large_scalars:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -48
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 48
+; ILP32E-FPELIM-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 48
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    lui a0, 524272
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 8(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 4(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 0(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 36(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 32(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 28(sp)
+; ILP32E-FPELIM-NEXT:    li a2, 1
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 24
+; ILP32E-FPELIM-NEXT:    mv a1, sp
+; ILP32E-FPELIM-NEXT:    sw a2, 24(sp)
+; ILP32E-FPELIM-NEXT:    call callee_large_scalars@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -48
+; ILP32E-FPELIM-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 48
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_scalars:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 48
+; ILP32E-WITHFP-NEXT:    sw ra, 44(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 40(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 48
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    lui a0, 524272
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 8(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 4(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 0(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 36(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 32(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 28(sp)
+; ILP32E-WITHFP-NEXT:    li a2, 1
+; ILP32E-WITHFP-NEXT:    addi a0, sp, 24
+; ILP32E-WITHFP-NEXT:    mv a1, sp
+; ILP32E-WITHFP-NEXT:    sw a2, 24(sp)
+; ILP32E-WITHFP-NEXT:    call callee_large_scalars@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -48
+; ILP32E-WITHFP-NEXT:    lw ra, 44(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 40(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_large_scalars:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 40
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi s0, sp, 40
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 524272
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 28(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 24(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 20(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a2, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, sp, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a1, sp
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a2, 16(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_large_scalars@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, s0, -40
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_large_scalars:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -32
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 40
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 40
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 524272
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 8(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 4(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 0(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 28(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 24(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 20(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a2, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, sp, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a1, sp
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a2, 16(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_large_scalars@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, s0, -40
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 32
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_large_scalars(i128 1, fp128 0xL00000000000000007FFF000000000000)
+  ret i32 %1
+}
+
+; Check that arguments larger than 2*xlen are handled correctly when their
+; address is passed on the stack rather than in memory
+
+; Must keep define on a single line due to an update_llc_test_checks.py limitation
+define i32 @callee_large_scalars_exhausted_regs(i32 %a, i32 %b, i32 %c, i32 %d, i32 %e, i32 %f, i32 %g, i128 %h, i32 %i, fp128 %j) {
+; ILP32E-FPELIM-LABEL: callee_large_scalars_exhausted_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a2, 0(a0)
+; ILP32E-FPELIM-NEXT:    lw a3, 0(a1)
+; ILP32E-FPELIM-NEXT:    lw a4, 4(a0)
+; ILP32E-FPELIM-NEXT:    lw a5, 12(a0)
+; ILP32E-FPELIM-NEXT:    lw a6, 12(a1)
+; ILP32E-FPELIM-NEXT:    lw a7, 4(a1)
+; ILP32E-FPELIM-NEXT:    lw a0, 8(a0)
+; ILP32E-FPELIM-NEXT:    lw a1, 8(a1)
+; ILP32E-FPELIM-NEXT:    xor a5, a6, a5
+; ILP32E-FPELIM-NEXT:    xor a4, a7, a4
+; ILP32E-FPELIM-NEXT:    or a4, a4, a5
+; ILP32E-FPELIM-NEXT:    xor a0, a1, a0
+; ILP32E-FPELIM-NEXT:    xor a2, a3, a2
+; ILP32E-FPELIM-NEXT:    or a0, a2, a0
+; ILP32E-FPELIM-NEXT:    or a0, a0, a4
+; ILP32E-FPELIM-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_scalars_exhausted_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a0, 12(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    lw a2, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw a3, 0(a1)
+; ILP32E-WITHFP-NEXT:    lw a4, 4(a0)
+; ILP32E-WITHFP-NEXT:    lw a5, 12(a0)
+; ILP32E-WITHFP-NEXT:    lw a6, 12(a1)
+; ILP32E-WITHFP-NEXT:    lw a7, 4(a1)
+; ILP32E-WITHFP-NEXT:    lw a0, 8(a0)
+; ILP32E-WITHFP-NEXT:    lw a1, 8(a1)
+; ILP32E-WITHFP-NEXT:    xor a5, a6, a5
+; ILP32E-WITHFP-NEXT:    xor a4, a7, a4
+; ILP32E-WITHFP-NEXT:    or a4, a4, a5
+; ILP32E-WITHFP-NEXT:    xor a0, a1, a0
+; ILP32E-WITHFP-NEXT:    xor a2, a3, a2
+; ILP32E-WITHFP-NEXT:    or a0, a2, a0
+; ILP32E-WITHFP-NEXT:    or a0, a0, a4
+; ILP32E-WITHFP-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_large_scalars_exhausted_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a1, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a2, 0(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a3, 0(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a4, 4(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a5, 12(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a6, 12(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a7, 4(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 8(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a1, 8(a1)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a5, a6, a5
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a4, a7, a4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    or a4, a4, a5
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a0, a1, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a2, a3, a2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    or a0, a2, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    or a0, a0, a4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_large_scalars_exhausted_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 12(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a1, 4(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a2, 0(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a3, 0(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a4, 4(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a5, 12(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a6, 12(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a7, 4(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 8(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a1, 8(a1)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a5, a6, a5
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a4, a7, a4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    or a4, a4, a5
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a0, a1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a2, a3, a2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    or a0, a2, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    or a0, a0, a4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %j_bitcast = bitcast fp128 %j to i128
+  %1 = icmp eq i128 %h, %j_bitcast
+  %2 = zext i1 %1 to i32
+  ret i32 %2
+}
+
+define i32 @caller_large_scalars_exhausted_regs() {
+; ILP32E-FPELIM-LABEL: caller_large_scalars_exhausted_regs:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-FPELIM-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 64
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 16
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 9
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 40
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 7
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 524272
+; ILP32E-FPELIM-NEXT:    sw a0, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 20(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 16(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 52(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 48(sp)
+; ILP32E-FPELIM-NEXT:    sw zero, 44(sp)
+; ILP32E-FPELIM-NEXT:    li a6, 8
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    li a2, 3
+; ILP32E-FPELIM-NEXT:    li a3, 4
+; ILP32E-FPELIM-NEXT:    li a4, 5
+; ILP32E-FPELIM-NEXT:    li a5, 6
+; ILP32E-FPELIM-NEXT:    sw a6, 40(sp)
+; ILP32E-FPELIM-NEXT:    call callee_large_scalars_exhausted_regs@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -64
+; ILP32E-FPELIM-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 64
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_scalars_exhausted_regs:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 64
+; ILP32E-WITHFP-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 64
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    addi a0, sp, 16
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 9
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    addi a0, sp, 40
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 7
+; ILP32E-WITHFP-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 524272
+; ILP32E-WITHFP-NEXT:    sw a0, 28(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 24(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 20(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 16(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 52(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 48(sp)
+; ILP32E-WITHFP-NEXT:    sw zero, 44(sp)
+; ILP32E-WITHFP-NEXT:    li a6, 8
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    li a2, 3
+; ILP32E-WITHFP-NEXT:    li a3, 4
+; ILP32E-WITHFP-NEXT:    li a4, 5
+; ILP32E-WITHFP-NEXT:    li a5, 6
+; ILP32E-WITHFP-NEXT:    sw a6, 40(sp)
+; ILP32E-WITHFP-NEXT:    call callee_large_scalars_exhausted_regs@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -64
+; ILP32E-WITHFP-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 64
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_large_scalars_exhausted_regs:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -48
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 56
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi s0, sp, 56
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, sp, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 9
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi a0, sp, 32
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 7
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a0, 524272
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 28(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 24(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 20(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 16(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 44(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 40(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 36(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a6, 8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a2, 3
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a3, 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a4, 5
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a5, 6
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a6, 32(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_large_scalars_exhausted_regs@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, s0, -56
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 48
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_large_scalars_exhausted_regs:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 56
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 56
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, sp, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 9
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, sp, 32
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 7
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a0, 524272
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, 28(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 24(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 20(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 16(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 44(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 40(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 36(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a6, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a2, 3
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a3, 4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a4, 5
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a5, 6
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a6, 32(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_large_scalars_exhausted_regs@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, s0, -56
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_large_scalars_exhausted_regs(
+      i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i128 8, i32 9,
+      fp128 0xL00000000000000007FFF000000000000)
+  ret i32 %1
+}
+
+; Ensure that libcalls generated in the middle-end obey the calling convention
+
+define i32 @caller_mixed_scalar_libcalls(i64 %a) {
+; ILP32E-FPELIM-LABEL: caller_mixed_scalar_libcalls:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-FPELIM-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    mv a2, a1
+; ILP32E-FPELIM-NEXT:    mv a1, a0
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call __floatditf@plt
+; ILP32E-FPELIM-NEXT:    lw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -24
+; ILP32E-FPELIM-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 24
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_mixed_scalar_libcalls:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    mv a2, a1
+; ILP32E-WITHFP-NEXT:    mv a1, a0
+; ILP32E-WITHFP-NEXT:    mv a0, sp
+; ILP32E-WITHFP-NEXT:    call __floatditf@plt
+; ILP32E-WITHFP-NEXT:    lw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -24
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 24
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_mixed_scalar_libcalls:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi s0, sp, 24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    andi sp, sp, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a2, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a1, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a0, sp
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call __floatditf@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, s0, -24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_mixed_scalar_libcalls:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    andi sp, sp, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a2, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a0, sp
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call __floatditf@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 0(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, s0, -24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = sitofp i64 %a to fp128
+  %2 = bitcast fp128 %1 to i128
+  %3 = trunc i128 %2 to i32
+  ret i32 %3
+}
+
+
+; Check passing of coerced integer arrays
+
+%struct.small = type { i32, i32* }
+
+define i32 @callee_small_coerced_struct([2 x i32] %a.coerce) {
+; ILP32E-FPELIM-LABEL: callee_small_coerced_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    xor a0, a0, a1
+; ILP32E-FPELIM-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_small_coerced_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    xor a0, a0, a1
+; ILP32E-WITHFP-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_small_coerced_struct:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    xor a0, a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    seqz a0, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_small_coerced_struct:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    xor a0, a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    seqz a0, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = extractvalue [2 x i32] %a.coerce, 0
+  %2 = extractvalue [2 x i32] %a.coerce, 1
+  %3 = icmp eq i32 %1, %2
+  %4 = zext i1 %3 to i32
+  ret i32 %4
+}
+
+define i32 @caller_small_coerced_struct() {
+; ILP32E-FPELIM-LABEL: caller_small_coerced_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    call callee_small_coerced_struct@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_small_coerced_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    call callee_small_coerced_struct@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_small_coerced_struct:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_small_coerced_struct@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_small_coerced_struct:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_small_coerced_struct@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call i32 @callee_small_coerced_struct([2 x i32] [i32 1, i32 2])
+  ret i32 %1
+}
+
+; Check large struct arguments, which are passed byval
+
+%struct.large = type { i32, i32, i32, i32 }
+
+define i32 @callee_large_struct(%struct.large* byval(%struct.large) align 4 %a) {
+; ILP32E-FPELIM-LABEL: callee_large_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lw a1, 0(a0)
+; ILP32E-FPELIM-NEXT:    lw a0, 12(a0)
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lw a1, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw a0, 12(a0)
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_large_struct:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a1, 0(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 12(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_large_struct:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a1, 0(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 12(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 0
+  %2 = getelementptr inbounds %struct.large, %struct.large* %a, i32 0, i32 3
+  %3 = load i32, i32* %1
+  %4 = load i32, i32* %2
+  %5 = add i32 %3, %4
+  ret i32 %5
+}
+
+define i32 @caller_large_struct() {
+; ILP32E-FPELIM-LABEL: caller_large_struct:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -36
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 36
+; ILP32E-FPELIM-NEXT:    sw ra, 32(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    sw a0, 16(sp)
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    sw a1, 20(sp)
+; ILP32E-FPELIM-NEXT:    li a2, 3
+; ILP32E-FPELIM-NEXT:    sw a2, 24(sp)
+; ILP32E-FPELIM-NEXT:    li a3, 4
+; ILP32E-FPELIM-NEXT:    sw a3, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 8(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 12(sp)
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call callee_large_struct@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 32(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 36
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_struct:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -40
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 40
+; ILP32E-WITHFP-NEXT:    sw ra, 36(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 32(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 40
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    sw a0, -24(s0)
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    sw a1, -20(s0)
+; ILP32E-WITHFP-NEXT:    li a2, 3
+; ILP32E-WITHFP-NEXT:    sw a2, -16(s0)
+; ILP32E-WITHFP-NEXT:    li a3, 4
+; ILP32E-WITHFP-NEXT:    sw a3, -12(s0)
+; ILP32E-WITHFP-NEXT:    sw a0, -40(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, -36(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, -32(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, -28(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, -40
+; ILP32E-WITHFP-NEXT:    call callee_large_struct@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 36(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 32(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 40
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_large_struct:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 36
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 16(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 20(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a2, 3
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a2, 24(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a3, 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a3, 28(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a2, 8(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a3, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a0, sp
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_large_struct@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_large_struct:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -32
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 40
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 40
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, -24(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, -20(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a2, 3
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a2, -16(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a3, 4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a3, -12(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a0, -40(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, -36(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a2, -32(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a3, -28(s0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi a0, s0, -40
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_large_struct@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 32
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %ls = alloca %struct.large, align 4
+  %1 = bitcast %struct.large* %ls to i8*
+  %a = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 0
+  store i32 1, i32* %a
+  %b = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 1
+  store i32 2, i32* %b
+  %c = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 2
+  store i32 3, i32* %c
+  %d = getelementptr inbounds %struct.large, %struct.large* %ls, i32 0, i32 3
+  store i32 4, i32* %d
+  %2 = call i32 @callee_large_struct(%struct.large* byval(%struct.large) align 4 %ls)
+  ret i32 %2
+}
+
+; Check return of 2x xlen structs
+
+define %struct.small @callee_small_struct_ret() {
+; ILP32E-FPELIM-LABEL: callee_small_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_small_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_small_struct_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_small_struct_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a0, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  ret %struct.small { i32 1, i32* null }
+}
+
+define i32 @caller_small_struct_ret() {
+; ILP32E-FPELIM-LABEL: caller_small_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    call callee_small_struct_ret@plt
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_small_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    call callee_small_struct_ret@plt
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_small_struct_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_small_struct_ret@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_0
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_small_struct_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_small_struct_ret@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call %struct.small @callee_small_struct_ret()
+  %2 = extractvalue %struct.small %1, 0
+  %3 = extractvalue %struct.small %1, 1
+  %4 = ptrtoint i32* %3 to i32
+  %5 = add i32 %2, %4
+  ret i32 %5
+}
+
+; Check return of >2x xlen scalars
+
+define fp128 @callee_large_scalar_ret() {
+; ILP32E-FPELIM-LABEL: callee_large_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lui a1, 524272
+; ILP32E-FPELIM-NEXT:    sw a1, 12(a0)
+; ILP32E-FPELIM-NEXT:    sw zero, 8(a0)
+; ILP32E-FPELIM-NEXT:    sw zero, 4(a0)
+; ILP32E-FPELIM-NEXT:    sw zero, 0(a0)
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    lui a1, 524272
+; ILP32E-WITHFP-NEXT:    sw a1, 12(a0)
+; ILP32E-WITHFP-NEXT:    sw zero, 8(a0)
+; ILP32E-WITHFP-NEXT:    sw zero, 4(a0)
+; ILP32E-WITHFP-NEXT:    sw zero, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_large_scalar_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lui a1, 524272
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 12(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 8(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 4(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw zero, 0(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_large_scalar_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lui a1, 524272
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, 12(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 8(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 4(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw zero, 0(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  ret fp128 0xL00000000000000007FFF000000000000
+}
+
+define void @caller_large_scalar_ret() {
+; ILP32E-FPELIM-LABEL: caller_large_scalar_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 32
+; ILP32E-FPELIM-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 32
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call callee_large_scalar_ret@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -32
+; ILP32E-FPELIM-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_scalar_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -32
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 32
+; ILP32E-WITHFP-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 32
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    mv a0, sp
+; ILP32E-WITHFP-NEXT:    call callee_large_scalar_ret@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -32
+; ILP32E-WITHFP-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 32
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_large_scalar_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi s0, sp, 24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a0, sp
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_large_scalar_ret@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, s0, -24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_large_scalar_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a0, sp
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_large_scalar_ret@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, s0, -24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = call fp128 @callee_large_scalar_ret()
+  ret void
+}
+
+; Check return of >2x xlen structs
+
+define void @callee_large_struct_ret(%struct.large* noalias sret(%struct.large) %agg.result) {
+; ILP32E-FPELIM-LABEL: callee_large_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    li a1, 1
+; ILP32E-FPELIM-NEXT:    sw a1, 0(a0)
+; ILP32E-FPELIM-NEXT:    li a1, 2
+; ILP32E-FPELIM-NEXT:    sw a1, 4(a0)
+; ILP32E-FPELIM-NEXT:    li a1, 3
+; ILP32E-FPELIM-NEXT:    sw a1, 8(a0)
+; ILP32E-FPELIM-NEXT:    li a1, 4
+; ILP32E-FPELIM-NEXT:    sw a1, 12(a0)
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: callee_large_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 16
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    li a1, 1
+; ILP32E-WITHFP-NEXT:    sw a1, 0(a0)
+; ILP32E-WITHFP-NEXT:    li a1, 2
+; ILP32E-WITHFP-NEXT:    sw a1, 4(a0)
+; ILP32E-WITHFP-NEXT:    li a1, 3
+; ILP32E-WITHFP-NEXT:    sw a1, 8(a0)
+; ILP32E-WITHFP-NEXT:    li a1, 4
+; ILP32E-WITHFP-NEXT:    sw a1, 12(a0)
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: callee_large_struct_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 0(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 4(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 3
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 8(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    li a1, 4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    sw a1, 12(a0)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    ret
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: callee_large_struct_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, 0(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 2
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, 4(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 3
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, 8(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    li a1, 4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    sw a1, 12(a0)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %a = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 0
+  store i32 1, i32* %a, align 4
+  %b = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 1
+  store i32 2, i32* %b, align 4
+  %c = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 2
+  store i32 3, i32* %c, align 4
+  %d = getelementptr inbounds %struct.large, %struct.large* %agg.result, i32 0, i32 3
+  store i32 4, i32* %d, align 4
+  ret void
+}
+
+define i32 @caller_large_struct_ret() {
+; ILP32E-FPELIM-LABEL: caller_large_struct_ret:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-FPELIM-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 24
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -8
+; ILP32E-FPELIM-NEXT:    mv a0, sp
+; ILP32E-FPELIM-NEXT:    call callee_large_struct_ret@plt
+; ILP32E-FPELIM-NEXT:    lw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -24
+; ILP32E-FPELIM-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 24
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller_large_struct_ret:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    mv a0, sp
+; ILP32E-WITHFP-NEXT:    call callee_large_struct_ret@plt
+; ILP32E-WITHFP-NEXT:    lw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lw a1, 12(sp)
+; ILP32E-WITHFP-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -24
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 24
+; ILP32E-WITHFP-NEXT:    ret
+;
+; ILP32E-FPELIM-SAVE-RESTORE-LABEL: caller_large_struct_ret:
+; ILP32E-FPELIM-SAVE-RESTORE:       # %bb.0:
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi s0, sp, 24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    andi sp, sp, -8
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    mv a0, sp
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    call callee_large_struct_ret@plt
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a0, 0(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    lw a1, 12(sp)
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, s0, -24
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-FPELIM-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+;
+; ILP32E-WITHFP-SAVE-RESTORE-LABEL: caller_large_struct_ret:
+; ILP32E-WITHFP-SAVE-RESTORE:       # %bb.0:
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call t0, __riscv_save_1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, -16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa_offset 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    andi sp, sp, -8
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    mv a0, sp
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    call callee_large_struct_ret@plt
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a0, 0(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    lw a1, 12(sp)
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    add a0, a0, a1
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, s0, -24
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    addi sp, sp, 16
+; ILP32E-WITHFP-SAVE-RESTORE-NEXT:    tail __riscv_restore_1
+  %1 = alloca %struct.large
+  call void @callee_large_struct_ret(%struct.large* sret(%struct.large) %1)
+  %2 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 0
+  %3 = load i32, i32* %2
+  %4 = getelementptr inbounds %struct.large, %struct.large* %1, i32 0, i32 3
+  %5 = load i32, i32* %4
+  %6 = add i32 %3, %5
+  ret i32 %6
+}
diff --git a/llvm/test/CodeGen/RISCV/calling-conv-lp64e.ll b/llvm/test/CodeGen/RISCV/calling-conv-lp64e.ll
new file mode 100644
index 000000000000..691a50677141
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/calling-conv-lp64e.ll
@@ -0,0 +1,221 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv64 -target-abi lp64e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=RV64I-LP64E-FPELIM %s
+; RUN: llc -mtriple=riscv64 -target-abi lp64e -verify-machineinstrs -frame-pointer=all < %s \
+; RUN:   | FileCheck -check-prefix=RV64I-LP64E-WITHFP %s
+
+; As well as calling convention details, we check that ra and fp are
+; consistently stored to fp-8 and fp-16.
+
+; Any tests that would have identical output for some combination of the lp64*
+; ABIs belong in calling-conv-*-common.ll. This file contains tests that will
+; have different output across those ABIs. i.e. where some arguments would be
+; passed according to the floating point ABI.
+
+; TODO: softened float values can be passed anyext.
+
+define i64 @callee_float_in_regs(i64 %a, float %b) nounwind {
+; RV64I-LP64E-FPELIM-LABEL: callee_float_in_regs:
+; RV64I-LP64E-FPELIM:       # %bb.0:
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-FPELIM-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    mv s0, a0
+; RV64I-LP64E-FPELIM-NEXT:    sext.w a0, a1
+; RV64I-LP64E-FPELIM-NEXT:    call __fixsfdi@plt
+; RV64I-LP64E-FPELIM-NEXT:    add a0, s0, a0
+; RV64I-LP64E-FPELIM-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-FPELIM-NEXT:    ret
+;
+; RV64I-LP64E-WITHFP-LABEL: callee_float_in_regs:
+; RV64I-LP64E-WITHFP:       # %bb.0:
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, -24
+; RV64I-LP64E-WITHFP-NEXT:    sd ra, 16(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    sd s0, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    sd s1, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    addi s0, sp, 24
+; RV64I-LP64E-WITHFP-NEXT:    mv s1, a0
+; RV64I-LP64E-WITHFP-NEXT:    sext.w a0, a1
+; RV64I-LP64E-WITHFP-NEXT:    call __fixsfdi@plt
+; RV64I-LP64E-WITHFP-NEXT:    add a0, s1, a0
+; RV64I-LP64E-WITHFP-NEXT:    ld ra, 16(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    ld s0, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    ld s1, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, 24
+; RV64I-LP64E-WITHFP-NEXT:    ret
+  %b_fptosi = fptosi float %b to i64
+  %1 = add i64 %a, %b_fptosi
+  ret i64 %1
+}
+
+define i64 @caller_float_in_regs() nounwind {
+; RV64I-LP64E-FPELIM-LABEL: caller_float_in_regs:
+; RV64I-LP64E-FPELIM:       # %bb.0:
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, -8
+; RV64I-LP64E-FPELIM-NEXT:    sd ra, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    li a0, 1
+; RV64I-LP64E-FPELIM-NEXT:    lui a1, 262144
+; RV64I-LP64E-FPELIM-NEXT:    call callee_float_in_regs@plt
+; RV64I-LP64E-FPELIM-NEXT:    ld ra, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, 8
+; RV64I-LP64E-FPELIM-NEXT:    ret
+;
+; RV64I-LP64E-WITHFP-LABEL: caller_float_in_regs:
+; RV64I-LP64E-WITHFP:       # %bb.0:
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-WITHFP-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    addi s0, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    li a0, 1
+; RV64I-LP64E-WITHFP-NEXT:    lui a1, 262144
+; RV64I-LP64E-WITHFP-NEXT:    call callee_float_in_regs@plt
+; RV64I-LP64E-WITHFP-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    ret
+  %1 = call i64 @callee_float_in_regs(i64 1, float 2.0)
+  ret i64 %1
+}
+
+define i64 @callee_float_on_stack(i128 %a, i128 %b, i128 %c, i128 %d, float %e) nounwind {
+; RV64I-LP64E-FPELIM-LABEL: callee_float_on_stack:
+; RV64I-LP64E-FPELIM:       # %bb.0:
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-FPELIM-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    addi s0, sp, 16
+; RV64I-LP64E-FPELIM-NEXT:    andi sp, sp, -16
+; RV64I-LP64E-FPELIM-NEXT:    lw a0, 16(s0)
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, s0, -16
+; RV64I-LP64E-FPELIM-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-FPELIM-NEXT:    ret
+;
+; RV64I-LP64E-WITHFP-LABEL: callee_float_on_stack:
+; RV64I-LP64E-WITHFP:       # %bb.0:
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-WITHFP-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    addi s0, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    andi sp, sp, -16
+; RV64I-LP64E-WITHFP-NEXT:    lw a0, 16(s0)
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, s0, -16
+; RV64I-LP64E-WITHFP-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    ret
+  %1 = trunc i128 %d to i64
+  %2 = bitcast float %e to i32
+  %3 = sext i32 %2 to i64
+  %4 = add i64 %1, %3
+  ret i64 %3
+}
+
+define i64 @caller_float_on_stack() nounwind {
+; RV64I-LP64E-FPELIM-LABEL: caller_float_on_stack:
+; RV64I-LP64E-FPELIM:       # %bb.0:
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, -48
+; RV64I-LP64E-FPELIM-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    addi s0, sp, 48
+; RV64I-LP64E-FPELIM-NEXT:    andi sp, sp, -16
+; RV64I-LP64E-FPELIM-NEXT:    lui a0, 264704
+; RV64I-LP64E-FPELIM-NEXT:    sd a0, 16(sp)
+; RV64I-LP64E-FPELIM-NEXT:    sd zero, 8(sp)
+; RV64I-LP64E-FPELIM-NEXT:    li a1, 4
+; RV64I-LP64E-FPELIM-NEXT:    li a0, 1
+; RV64I-LP64E-FPELIM-NEXT:    li a2, 2
+; RV64I-LP64E-FPELIM-NEXT:    li a4, 3
+; RV64I-LP64E-FPELIM-NEXT:    sd a1, 0(sp)
+; RV64I-LP64E-FPELIM-NEXT:    li a1, 0
+; RV64I-LP64E-FPELIM-NEXT:    li a3, 0
+; RV64I-LP64E-FPELIM-NEXT:    li a5, 0
+; RV64I-LP64E-FPELIM-NEXT:    call callee_float_on_stack@plt
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, s0, -48
+; RV64I-LP64E-FPELIM-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, 48
+; RV64I-LP64E-FPELIM-NEXT:    ret
+;
+; RV64I-LP64E-WITHFP-LABEL: caller_float_on_stack:
+; RV64I-LP64E-WITHFP:       # %bb.0:
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, -48
+; RV64I-LP64E-WITHFP-NEXT:    sd ra, 40(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    sd s0, 32(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    addi s0, sp, 48
+; RV64I-LP64E-WITHFP-NEXT:    andi sp, sp, -16
+; RV64I-LP64E-WITHFP-NEXT:    lui a0, 264704
+; RV64I-LP64E-WITHFP-NEXT:    sd a0, 16(sp)
+; RV64I-LP64E-WITHFP-NEXT:    sd zero, 8(sp)
+; RV64I-LP64E-WITHFP-NEXT:    li a1, 4
+; RV64I-LP64E-WITHFP-NEXT:    li a0, 1
+; RV64I-LP64E-WITHFP-NEXT:    li a2, 2
+; RV64I-LP64E-WITHFP-NEXT:    li a4, 3
+; RV64I-LP64E-WITHFP-NEXT:    sd a1, 0(sp)
+; RV64I-LP64E-WITHFP-NEXT:    li a1, 0
+; RV64I-LP64E-WITHFP-NEXT:    li a3, 0
+; RV64I-LP64E-WITHFP-NEXT:    li a5, 0
+; RV64I-LP64E-WITHFP-NEXT:    call callee_float_on_stack@plt
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, s0, -48
+; RV64I-LP64E-WITHFP-NEXT:    ld ra, 40(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, 48
+; RV64I-LP64E-WITHFP-NEXT:    ret
+  %1 = call i64 @callee_float_on_stack(i128 1, i128 2, i128 3, i128 4, float 5.0)
+  ret i64 %1
+}
+
+define float @callee_tiny_scalar_ret() nounwind {
+; RV64I-LP64E-FPELIM-LABEL: callee_tiny_scalar_ret:
+; RV64I-LP64E-FPELIM:       # %bb.0:
+; RV64I-LP64E-FPELIM-NEXT:    lui a0, 260096
+; RV64I-LP64E-FPELIM-NEXT:    ret
+;
+; RV64I-LP64E-WITHFP-LABEL: callee_tiny_scalar_ret:
+; RV64I-LP64E-WITHFP:       # %bb.0:
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-WITHFP-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    addi s0, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    lui a0, 260096
+; RV64I-LP64E-WITHFP-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    ret
+  ret float 1.0
+}
+
+; The sign extension of the float return is necessary, as softened floats are
+; passed anyext.
+
+define i64 @caller_tiny_scalar_ret() nounwind {
+; RV64I-LP64E-FPELIM-LABEL: caller_tiny_scalar_ret:
+; RV64I-LP64E-FPELIM:       # %bb.0:
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, -8
+; RV64I-LP64E-FPELIM-NEXT:    sd ra, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-FPELIM-NEXT:    call callee_tiny_scalar_ret@plt
+; RV64I-LP64E-FPELIM-NEXT:    sext.w a0, a0
+; RV64I-LP64E-FPELIM-NEXT:    ld ra, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-FPELIM-NEXT:    addi sp, sp, 8
+; RV64I-LP64E-FPELIM-NEXT:    ret
+;
+; RV64I-LP64E-WITHFP-LABEL: caller_tiny_scalar_ret:
+; RV64I-LP64E-WITHFP:       # %bb.0:
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-WITHFP-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; RV64I-LP64E-WITHFP-NEXT:    addi s0, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    call callee_tiny_scalar_ret@plt
+; RV64I-LP64E-WITHFP-NEXT:    sext.w a0, a0
+; RV64I-LP64E-WITHFP-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; RV64I-LP64E-WITHFP-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-WITHFP-NEXT:    ret
+  %1 = call float @callee_tiny_scalar_ret()
+  %2 = bitcast float %1 to i32
+  %3 = sext i32 %2 to i64
+  ret i64 %3
+}
diff --git a/llvm/test/CodeGen/RISCV/calling-conv-rv32f-ilp32e.ll b/llvm/test/CodeGen/RISCV/calling-conv-rv32f-ilp32e.ll
new file mode 100644
index 000000000000..09a8d4d4e757
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/calling-conv-rv32f-ilp32e.ll
@@ -0,0 +1,83 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32IF-ILP32E
+
+; Exercises the ILP32E calling convention code in the case that f32 is a legal
+; type. As well as testing that lowering is correct, these tests also aim to
+; check that floating point load/store or integer load/store is chosen
+; optimally when floats are passed on the stack.
+
+define float @onstack_f32_noop(i64 %a, i64 %b, i64 %c, i64 %d, float %e, float %f) nounwind {
+; RV32IF-ILP32E-LABEL: onstack_f32_noop:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    lw a0, 12(sp)
+; RV32IF-ILP32E-NEXT:    ret
+  ret float %f
+}
+
+define float @onstack_f32_fadd(i64 %a, i64 %b, i64 %c, i64 %d, float %e, float %f) nounwind {
+; RV32IF-ILP32E-LABEL: onstack_f32_fadd:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    flw ft0, 12(sp)
+; RV32IF-ILP32E-NEXT:    flw ft1, 8(sp)
+; RV32IF-ILP32E-NEXT:    fadd.s ft0, ft1, ft0
+; RV32IF-ILP32E-NEXT:    fmv.x.w a0, ft0
+; RV32IF-ILP32E-NEXT:    ret
+  %1 = fadd float %e, %f
+  ret float %1
+}
+
+define float @caller_onstack_f32_noop(float %a) nounwind {
+; RV32IF-ILP32E-LABEL: caller_onstack_f32_noop:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    addi sp, sp, -20
+; RV32IF-ILP32E-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; RV32IF-ILP32E-NEXT:    sw a0, 12(sp)
+; RV32IF-ILP32E-NEXT:    lui a0, 264704
+; RV32IF-ILP32E-NEXT:    sw a0, 8(sp)
+; RV32IF-ILP32E-NEXT:    sw zero, 4(sp)
+; RV32IF-ILP32E-NEXT:    li a1, 4
+; RV32IF-ILP32E-NEXT:    li a0, 1
+; RV32IF-ILP32E-NEXT:    li a2, 2
+; RV32IF-ILP32E-NEXT:    li a4, 3
+; RV32IF-ILP32E-NEXT:    sw a1, 0(sp)
+; RV32IF-ILP32E-NEXT:    li a1, 0
+; RV32IF-ILP32E-NEXT:    li a3, 0
+; RV32IF-ILP32E-NEXT:    li a5, 0
+; RV32IF-ILP32E-NEXT:    call onstack_f32_noop@plt
+; RV32IF-ILP32E-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; RV32IF-ILP32E-NEXT:    addi sp, sp, 20
+; RV32IF-ILP32E-NEXT:    ret
+  %1 = call float @onstack_f32_noop(i64 1, i64 2, i64 3, i64 4, float 5.0, float %a)
+  ret float %1
+}
+
+define float @caller_onstack_f32_fadd(float %a, float %b) nounwind {
+; RV32IF-ILP32E-LABEL: caller_onstack_f32_fadd:
+; RV32IF-ILP32E:       # %bb.0:
+; RV32IF-ILP32E-NEXT:    addi sp, sp, -20
+; RV32IF-ILP32E-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; RV32IF-ILP32E-NEXT:    fmv.w.x ft0, a1
+; RV32IF-ILP32E-NEXT:    fmv.w.x ft1, a0
+; RV32IF-ILP32E-NEXT:    fadd.s ft2, ft1, ft0
+; RV32IF-ILP32E-NEXT:    fsub.s ft0, ft0, ft1
+; RV32IF-ILP32E-NEXT:    sw zero, 4(sp)
+; RV32IF-ILP32E-NEXT:    li a0, 4
+; RV32IF-ILP32E-NEXT:    sw a0, 0(sp)
+; RV32IF-ILP32E-NEXT:    fsw ft0, 12(sp)
+; RV32IF-ILP32E-NEXT:    li a0, 1
+; RV32IF-ILP32E-NEXT:    li a2, 2
+; RV32IF-ILP32E-NEXT:    li a4, 3
+; RV32IF-ILP32E-NEXT:    fsw ft2, 8(sp)
+; RV32IF-ILP32E-NEXT:    li a1, 0
+; RV32IF-ILP32E-NEXT:    li a3, 0
+; RV32IF-ILP32E-NEXT:    li a5, 0
+; RV32IF-ILP32E-NEXT:    call onstack_f32_noop@plt
+; RV32IF-ILP32E-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; RV32IF-ILP32E-NEXT:    addi sp, sp, 20
+; RV32IF-ILP32E-NEXT:    ret
+  %1 = fadd float %a, %b
+  %2 = fsub float %b, %a
+  %3 = call float @onstack_f32_noop(i64 1, i64 2, i64 3, i64 4, float %1, float %2)
+  ret float %3
+}
diff --git a/llvm/test/CodeGen/RISCV/rv64e.ll b/llvm/test/CodeGen/RISCV/rv64e.ll
new file mode 100644
index 000000000000..093d503750ab
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/rv64e.ll
@@ -0,0 +1,25 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 2
+; RUN: llc -mtriple=riscv64 -mattr=+e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s
+
+; TODO: Add more tests.
+
+define i64 @exhausted(i64 %a, i64 %b, i64 %c, i64 %d, i64 %e, i64 %f, i64 %g) {
+; CHECK-LABEL: exhausted:
+; CHECK:       # %bb.0:
+; CHECK-NEXT:    ld t0, 0(sp)
+; CHECK-NEXT:    add a0, a0, a1
+; CHECK-NEXT:    add a2, a3, a2
+; CHECK-NEXT:    add a0, a2, a0
+; CHECK-NEXT:    add a4, a5, a4
+; CHECK-NEXT:    add a0, a4, a0
+; CHECK-NEXT:    add a0, t0, a0
+; CHECK-NEXT:    ret
+  %1 = add i64 %a, %b
+  %2 = add i64 %c, %1
+  %3 = add i64 %d, %2
+  %4 = add i64 %e, %3
+  %5 = add i64 %f, %4
+  %6 = add i64 %g, %5
+  ret i64 %6
+}
diff --git a/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll b/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll
index f10dfbd313cc..933dda86f5e3 100644
--- a/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll
+++ b/llvm/test/CodeGen/RISCV/stack-realignment-with-variable-sized-objects.ll
@@ -1,8 +1,12 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32I-ILP32E
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV64I
+; RUN: llc -mtriple=riscv64 -target-abi lp64e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV64I-LP64E
 
 declare void @callee(ptr, ptr)
 
@@ -34,6 +38,33 @@ define void @caller(i32 %n) {
 ; RV32I-NEXT:    addi sp, sp, 64
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 64
+; RV32I-ILP32E-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s1, 52(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    .cfi_offset s1, -12
+; RV32I-ILP32E-NEXT:    addi s0, sp, 64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -64
+; RV32I-ILP32E-NEXT:    mv s1, sp
+; RV32I-ILP32E-NEXT:    addi a0, a0, 3
+; RV32I-ILP32E-NEXT:    andi a0, a0, -4
+; RV32I-ILP32E-NEXT:    sub a0, sp, a0
+; RV32I-ILP32E-NEXT:    mv sp, a0
+; RV32I-ILP32E-NEXT:    mv a1, s1
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -64
+; RV32I-ILP32E-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s1, 52(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 64
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -64
@@ -62,6 +93,35 @@ define void @caller(i32 %n) {
 ; RV64I-NEXT:    ld s1, 40(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 64
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -64
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 64
+; RV64I-LP64E-NEXT:    sd ra, 56(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 48(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s1, 40(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    .cfi_offset s1, -24
+; RV64I-LP64E-NEXT:    addi s0, sp, 64
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    andi sp, sp, -64
+; RV64I-LP64E-NEXT:    mv s1, sp
+; RV64I-LP64E-NEXT:    slli a0, a0, 32
+; RV64I-LP64E-NEXT:    srli a0, a0, 32
+; RV64I-LP64E-NEXT:    addi a0, a0, 7
+; RV64I-LP64E-NEXT:    andi a0, a0, -8
+; RV64I-LP64E-NEXT:    sub a0, sp, a0
+; RV64I-LP64E-NEXT:    mv sp, a0
+; RV64I-LP64E-NEXT:    mv a1, s1
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -64
+; RV64I-LP64E-NEXT:    ld ra, 56(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s1, 40(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 64
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, i32 %n
   %2 = alloca i32, align 64
   call void @callee(ptr %1, ptr %2)
diff --git a/llvm/test/CodeGen/RISCV/stack-realignment.ll b/llvm/test/CodeGen/RISCV/stack-realignment.ll
index d87db54fd5bf..1b10afe5dd21 100644
--- a/llvm/test/CodeGen/RISCV/stack-realignment.ll
+++ b/llvm/test/CodeGen/RISCV/stack-realignment.ll
@@ -1,11 +1,135 @@
 ; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
 ; RUN: llc -mtriple=riscv32 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV32I
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV32I-ILP32E
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck %s -check-prefix=RV64I
+; RUN: llc -mtriple=riscv64 -target-abi lp64e -verify-machineinstrs < %s \
+; RUN:   | FileCheck %s -check-prefix=RV64I-LP64E
 
 declare void @callee(ptr)
 
+define void @caller16() {
+; RV32I-LABEL: caller16:
+; RV32I:       # %bb.0:
+; RV32I-NEXT:    addi sp, sp, -16
+; RV32I-NEXT:    .cfi_def_cfa_offset 16
+; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-NEXT:    .cfi_offset ra, -4
+; RV32I-NEXT:    mv a0, sp
+; RV32I-NEXT:    call callee@plt
+; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-NEXT:    addi sp, sp, 16
+; RV32I-NEXT:    ret
+;
+; RV32I-ILP32E-LABEL: caller16:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -16
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 16
+; RV32I-ILP32E-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 16
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -16
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -16
+; RV32I-ILP32E-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 16
+; RV32I-ILP32E-NEXT:    ret
+;
+; RV64I-LABEL: caller16:
+; RV64I:       # %bb.0:
+; RV64I-NEXT:    addi sp, sp, -16
+; RV64I-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-NEXT:    .cfi_offset ra, -8
+; RV64I-NEXT:    mv a0, sp
+; RV64I-NEXT:    call callee@plt
+; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-NEXT:    addi sp, sp, 16
+; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller16:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -32
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 32
+; RV64I-LP64E-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 32
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    andi sp, sp, -16
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -32
+; RV64I-LP64E-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 32
+; RV64I-LP64E-NEXT:    ret
+  %1 = alloca i8, align 16
+  call void @callee(i8* %1)
+  ret void
+}
+
+define void @caller_no_realign16() "no-realign-stack" {
+; RV32I-LABEL: caller_no_realign16:
+; RV32I:       # %bb.0:
+; RV32I-NEXT:    addi sp, sp, -16
+; RV32I-NEXT:    .cfi_def_cfa_offset 16
+; RV32I-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; RV32I-NEXT:    .cfi_offset ra, -4
+; RV32I-NEXT:    mv a0, sp
+; RV32I-NEXT:    call callee@plt
+; RV32I-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; RV32I-NEXT:    addi sp, sp, 16
+; RV32I-NEXT:    ret
+;
+; RV32I-ILP32E-LABEL: caller_no_realign16:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
+; RV64I-LABEL: caller_no_realign16:
+; RV64I:       # %bb.0:
+; RV64I-NEXT:    addi sp, sp, -16
+; RV64I-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-NEXT:    .cfi_offset ra, -8
+; RV64I-NEXT:    mv a0, sp
+; RV64I-NEXT:    call callee@plt
+; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-NEXT:    addi sp, sp, 16
+; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign16:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
+  %1 = alloca i8, align 16
+  call void @callee(i8* %1)
+  ret void
+}
+
 define void @caller32() {
 ; RV32I-LABEL: caller32:
 ; RV32I:       # %bb.0:
@@ -26,6 +150,25 @@ define void @caller32() {
 ; RV32I-NEXT:    addi sp, sp, 32
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller32:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -32
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 32
+; RV32I-ILP32E-NEXT:    sw ra, 28(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 24(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 32
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -32
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -32
+; RV32I-ILP32E-NEXT:    lw ra, 28(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 24(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 32
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller32:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -32
@@ -44,6 +187,25 @@ define void @caller32() {
 ; RV64I-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 32
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller32:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -32
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 32
+; RV64I-LP64E-NEXT:    sd ra, 24(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 16(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 32
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    andi sp, sp, -32
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -32
+; RV64I-LP64E-NEXT:    ld ra, 24(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 16(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 32
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 32
   call void @callee(ptr %1)
   ret void
@@ -62,6 +224,18 @@ define void @caller_no_realign32() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign32:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign32:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -73,6 +247,18 @@ define void @caller_no_realign32() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign32:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 32
   call void @callee(ptr %1)
   ret void
@@ -98,6 +284,25 @@ define void @caller64() {
 ; RV32I-NEXT:    addi sp, sp, 64
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller64:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 64
+; RV32I-ILP32E-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 64
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -64
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -64
+; RV32I-ILP32E-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 64
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller64:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -64
@@ -116,6 +321,25 @@ define void @caller64() {
 ; RV64I-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 64
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller64:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -64
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 64
+; RV64I-LP64E-NEXT:    sd ra, 56(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 48(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 64
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    andi sp, sp, -64
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -64
+; RV64I-LP64E-NEXT:    ld ra, 56(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 64
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 64
   call void @callee(ptr %1)
   ret void
@@ -134,6 +358,18 @@ define void @caller_no_realign64() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign64:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign64:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -145,6 +381,18 @@ define void @caller_no_realign64() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign64:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 64
   call void @callee(ptr %1)
   ret void
@@ -170,6 +418,25 @@ define void @caller128() {
 ; RV32I-NEXT:    addi sp, sp, 128
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller128:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -128
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 128
+; RV32I-ILP32E-NEXT:    sw ra, 124(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 120(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 128
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -128
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -128
+; RV32I-ILP32E-NEXT:    lw ra, 124(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 120(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 128
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller128:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -128
@@ -188,6 +455,25 @@ define void @caller128() {
 ; RV64I-NEXT:    ld s0, 112(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 128
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller128:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -128
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 128
+; RV64I-LP64E-NEXT:    sd ra, 120(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 112(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 128
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    andi sp, sp, -128
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -128
+; RV64I-LP64E-NEXT:    ld ra, 120(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 112(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 128
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 128
   call void @callee(ptr %1)
   ret void
@@ -206,6 +492,18 @@ define void @caller_no_realign128() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign128:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign128:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -217,6 +515,18 @@ define void @caller_no_realign128() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign128:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 128
   call void @callee(ptr %1)
   ret void
@@ -242,6 +552,25 @@ define void @caller256() {
 ; RV32I-NEXT:    addi sp, sp, 256
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller256:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -256
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 256
+; RV32I-ILP32E-NEXT:    sw ra, 252(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 248(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 256
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -256
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -256
+; RV32I-ILP32E-NEXT:    lw ra, 252(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 248(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 256
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller256:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -256
@@ -260,6 +589,25 @@ define void @caller256() {
 ; RV64I-NEXT:    ld s0, 240(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 256
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller256:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -256
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 256
+; RV64I-LP64E-NEXT:    sd ra, 248(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 240(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 256
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    andi sp, sp, -256
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -256
+; RV64I-LP64E-NEXT:    ld ra, 248(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 240(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 256
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 256
   call void @callee(ptr %1)
   ret void
@@ -278,6 +626,18 @@ define void @caller_no_realign256() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign256:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign256:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -289,6 +649,18 @@ define void @caller_no_realign256() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign256:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 256
   call void @callee(ptr %1)
   ret void
@@ -314,6 +686,25 @@ define void @caller512() {
 ; RV32I-NEXT:    addi sp, sp, 1024
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller512:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -1024
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 1024
+; RV32I-ILP32E-NEXT:    sw ra, 1020(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 1016(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 1024
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    andi sp, sp, -512
+; RV32I-ILP32E-NEXT:    addi a0, sp, 512
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -1024
+; RV32I-ILP32E-NEXT:    lw ra, 1020(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 1016(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 1024
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller512:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -1024
@@ -332,6 +723,25 @@ define void @caller512() {
 ; RV64I-NEXT:    ld s0, 1008(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 1024
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller512:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -1024
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 1024
+; RV64I-LP64E-NEXT:    sd ra, 1016(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 1008(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 1024
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    andi sp, sp, -512
+; RV64I-LP64E-NEXT:    addi a0, sp, 512
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -1024
+; RV64I-LP64E-NEXT:    ld ra, 1016(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 1008(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 1024
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 512
   call void @callee(ptr %1)
   ret void
@@ -350,6 +760,18 @@ define void @caller_no_realign512() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign512:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign512:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -361,6 +783,18 @@ define void @caller_no_realign512() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign512:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 512
   call void @callee(ptr %1)
   ret void
@@ -388,6 +822,27 @@ define void @caller1024() {
 ; RV32I-NEXT:    addi sp, sp, 2032
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller1024:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 2044
+; RV32I-ILP32E-NEXT:    sw ra, 2040(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 2036(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    addi sp, sp, -4
+; RV32I-ILP32E-NEXT:    andi sp, sp, -1024
+; RV32I-ILP32E-NEXT:    addi a0, sp, 1024
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    addi sp, s0, -2048
+; RV32I-ILP32E-NEXT:    addi sp, sp, 4
+; RV32I-ILP32E-NEXT:    lw ra, 2040(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 2036(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 2044
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller1024:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -2032
@@ -408,6 +863,27 @@ define void @caller1024() {
 ; RV64I-NEXT:    ld s0, 2016(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 2032
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller1024:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -2040
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 2040
+; RV64I-LP64E-NEXT:    sd ra, 2032(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 2024(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 2040
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    addi sp, sp, -8
+; RV64I-LP64E-NEXT:    andi sp, sp, -1024
+; RV64I-LP64E-NEXT:    addi a0, sp, 1024
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    addi sp, s0, -2048
+; RV64I-LP64E-NEXT:    addi sp, sp, 8
+; RV64I-LP64E-NEXT:    ld ra, 2032(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 2024(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 2040
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 1024
   call void @callee(ptr %1)
   ret void
@@ -426,6 +902,18 @@ define void @caller_no_realign1024() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign1024:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign1024:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -437,6 +925,18 @@ define void @caller_no_realign1024() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign1024:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 1024
   call void @callee(ptr %1)
   ret void
@@ -468,6 +968,31 @@ define void @caller2048() {
 ; RV32I-NEXT:    addi sp, sp, 2032
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller2048:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 2044
+; RV32I-ILP32E-NEXT:    sw ra, 2040(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 2036(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    addi sp, sp, -2048
+; RV32I-ILP32E-NEXT:    addi sp, sp, -4
+; RV32I-ILP32E-NEXT:    andi sp, sp, -2048
+; RV32I-ILP32E-NEXT:    addi a0, sp, 2047
+; RV32I-ILP32E-NEXT:    addi a0, a0, 1
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lui a0, 1
+; RV32I-ILP32E-NEXT:    sub sp, s0, a0
+; RV32I-ILP32E-NEXT:    addi sp, sp, 2044
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    lw ra, 2040(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 2036(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 2044
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller2048:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -2032
@@ -492,6 +1017,31 @@ define void @caller2048() {
 ; RV64I-NEXT:    ld s0, 2016(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 2032
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller2048:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -2040
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 2040
+; RV64I-LP64E-NEXT:    sd ra, 2032(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 2024(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 2040
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    addi sp, sp, -2048
+; RV64I-LP64E-NEXT:    addi sp, sp, -8
+; RV64I-LP64E-NEXT:    andi sp, sp, -2048
+; RV64I-LP64E-NEXT:    addi a0, sp, 2047
+; RV64I-LP64E-NEXT:    addi a0, a0, 1
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    lui a0, 1
+; RV64I-LP64E-NEXT:    sub sp, s0, a0
+; RV64I-LP64E-NEXT:    addi sp, sp, 2040
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ld ra, 2032(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 2024(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 2040
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 2048
   call void @callee(ptr %1)
   ret void
@@ -510,6 +1060,18 @@ define void @caller_no_realign2048() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign2048:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign2048:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -521,6 +1083,18 @@ define void @caller_no_realign2048() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign2048:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 2048
   call void @callee(ptr %1)
   ret void
@@ -554,6 +1128,33 @@ define void @caller4096() {
 ; RV32I-NEXT:    addi sp, sp, 2032
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller4096:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 2044
+; RV32I-ILP32E-NEXT:    sw ra, 2040(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    sw s0, 2036(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    .cfi_offset s0, -8
+; RV32I-ILP32E-NEXT:    addi s0, sp, 2044
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa s0, 0
+; RV32I-ILP32E-NEXT:    lui a0, 2
+; RV32I-ILP32E-NEXT:    addi a0, a0, -2044
+; RV32I-ILP32E-NEXT:    sub sp, sp, a0
+; RV32I-ILP32E-NEXT:    srli a0, sp, 12
+; RV32I-ILP32E-NEXT:    slli sp, a0, 12
+; RV32I-ILP32E-NEXT:    lui a0, 1
+; RV32I-ILP32E-NEXT:    add a0, sp, a0
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lui a0, 2
+; RV32I-ILP32E-NEXT:    sub sp, s0, a0
+; RV32I-ILP32E-NEXT:    addi a0, a0, -2044
+; RV32I-ILP32E-NEXT:    add sp, sp, a0
+; RV32I-ILP32E-NEXT:    lw ra, 2040(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    lw s0, 2036(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 2044
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller4096:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -2032
@@ -580,6 +1181,33 @@ define void @caller4096() {
 ; RV64I-NEXT:    ld s0, 2016(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 2032
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller4096:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -2040
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 2040
+; RV64I-LP64E-NEXT:    sd ra, 2032(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    sd s0, 2024(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    .cfi_offset s0, -16
+; RV64I-LP64E-NEXT:    addi s0, sp, 2040
+; RV64I-LP64E-NEXT:    .cfi_def_cfa s0, 0
+; RV64I-LP64E-NEXT:    lui a0, 2
+; RV64I-LP64E-NEXT:    addiw a0, a0, -2040
+; RV64I-LP64E-NEXT:    sub sp, sp, a0
+; RV64I-LP64E-NEXT:    srli a0, sp, 12
+; RV64I-LP64E-NEXT:    slli sp, a0, 12
+; RV64I-LP64E-NEXT:    lui a0, 1
+; RV64I-LP64E-NEXT:    add a0, sp, a0
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    lui a0, 2
+; RV64I-LP64E-NEXT:    sub sp, s0, a0
+; RV64I-LP64E-NEXT:    addiw a0, a0, -2040
+; RV64I-LP64E-NEXT:    add sp, sp, a0
+; RV64I-LP64E-NEXT:    ld ra, 2032(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    ld s0, 2024(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 2040
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 4096
   call void @callee(ptr %1)
   ret void
@@ -598,6 +1226,18 @@ define void @caller_no_realign4096() "no-realign-stack" {
 ; RV32I-NEXT:    addi sp, sp, 16
 ; RV32I-NEXT:    ret
 ;
+; RV32I-ILP32E-LABEL: caller_no_realign4096:
+; RV32I-ILP32E:       # %bb.0:
+; RV32I-ILP32E-NEXT:    addi sp, sp, -8
+; RV32I-ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; RV32I-ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; RV32I-ILP32E-NEXT:    .cfi_offset ra, -4
+; RV32I-ILP32E-NEXT:    mv a0, sp
+; RV32I-ILP32E-NEXT:    call callee@plt
+; RV32I-ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; RV32I-ILP32E-NEXT:    addi sp, sp, 8
+; RV32I-ILP32E-NEXT:    ret
+;
 ; RV64I-LABEL: caller_no_realign4096:
 ; RV64I:       # %bb.0:
 ; RV64I-NEXT:    addi sp, sp, -16
@@ -609,6 +1249,18 @@ define void @caller_no_realign4096() "no-realign-stack" {
 ; RV64I-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
 ; RV64I-NEXT:    addi sp, sp, 16
 ; RV64I-NEXT:    ret
+;
+; RV64I-LP64E-LABEL: caller_no_realign4096:
+; RV64I-LP64E:       # %bb.0:
+; RV64I-LP64E-NEXT:    addi sp, sp, -16
+; RV64I-LP64E-NEXT:    .cfi_def_cfa_offset 16
+; RV64I-LP64E-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; RV64I-LP64E-NEXT:    .cfi_offset ra, -8
+; RV64I-LP64E-NEXT:    mv a0, sp
+; RV64I-LP64E-NEXT:    call callee@plt
+; RV64I-LP64E-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; RV64I-LP64E-NEXT:    addi sp, sp, 16
+; RV64I-LP64E-NEXT:    ret
   %1 = alloca i8, align 4096
   call void @callee(ptr %1)
   ret void
diff --git a/llvm/test/CodeGen/RISCV/target-abi-valid.ll b/llvm/test/CodeGen/RISCV/target-abi-valid.ll
index 2d4079601f7b..53e427085733 100644
--- a/llvm/test/CodeGen/RISCV/target-abi-valid.ll
+++ b/llvm/test/CodeGen/RISCV/target-abi-valid.ll
@@ -2,6 +2,8 @@
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv32 -target-abi ilp32 < %s \
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e < %s 2>&1 \
+; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv32 -mattr=+f -target-abi ilp32 < %s \
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv32 -mattr=+d -target-abi ilp32 < %s \
@@ -10,6 +12,8 @@
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv64 -target-abi lp64 < %s \
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
+; RUN: llc -mtriple=riscv64 -target-abi lp64e < %s \
+; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv64 -mattr=+f -target-abi lp64 < %s \
 ; RUN:   | FileCheck -check-prefix=CHECK-IMP %s
 ; RUN: llc -mtriple=riscv64 -mattr=+d -target-abi lp64 < %s \
@@ -33,8 +37,3 @@ define void @nothing() nounwind {
 ; CHECK-IMP-NEXT:    ret
   ret void
 }
-
-; RUN: not --crash llc -mtriple=riscv32 -target-abi ilp32e < %s 2>&1 \
-; RUN:   | FileCheck -check-prefix=CHECK-UNIMP %s
-
-; CHECK-UNIMP: LLVM ERROR: Don't know how to lower this ABI
diff --git a/llvm/test/CodeGen/RISCV/vararg-ilp32e.ll b/llvm/test/CodeGen/RISCV/vararg-ilp32e.ll
new file mode 100644
index 000000000000..ac0137544553
--- /dev/null
+++ b/llvm/test/CodeGen/RISCV/vararg-ilp32e.ll
@@ -0,0 +1,144 @@
+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -frame-pointer=all -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-WITHFP %s
+
+declare void @llvm.va_start(i8*)
+declare void @llvm.va_end(i8*)
+declare void @abort()
+
+define i32 @caller(i32 %a) {
+; ILP32E-LABEL: caller:
+; ILP32E:       # %bb.0: # %entry
+; ILP32E-NEXT:    addi sp, sp, -8
+; ILP32E-NEXT:    .cfi_def_cfa_offset 8
+; ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    .cfi_offset ra, -4
+; ILP32E-NEXT:    .cfi_offset s0, -8
+; ILP32E-NEXT:    mv s0, a0
+; ILP32E-NEXT:    li a0, 1
+; ILP32E-NEXT:    lui a2, 262144
+; ILP32E-NEXT:    li a1, 0
+; ILP32E-NEXT:    call va_double@plt
+; ILP32E-NEXT:    mv a0, s0
+; ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    addi sp, sp, 8
+; ILP32E-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: caller:
+; ILP32E-WITHFP:       # %bb.0: # %entry
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 12
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -4
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -8
+; ILP32E-WITHFP-NEXT:    .cfi_offset s1, -12
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 0
+; ILP32E-WITHFP-NEXT:    mv s1, a0
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    lui a2, 262144
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call va_double@plt
+; ILP32E-WITHFP-NEXT:    mv a0, s1
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 12
+; ILP32E-WITHFP-NEXT:    ret
+entry:
+  call void (i32, ...) @va_double(i32 1, double 2.000000e+00)
+  ret i32 %a
+}
+
+define void @va_double(i32 %n, ...) {
+; ILP32E-LABEL: va_double:
+; ILP32E:       # %bb.0: # %entry
+; ILP32E-NEXT:    addi sp, sp, -32
+; ILP32E-NEXT:    .cfi_def_cfa_offset 32
+; ILP32E-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-NEXT:    .cfi_offset ra, -28
+; ILP32E-NEXT:    sw a5, 28(sp)
+; ILP32E-NEXT:    sw a4, 24(sp)
+; ILP32E-NEXT:    sw a3, 20(sp)
+; ILP32E-NEXT:    sw a2, 16(sp)
+; ILP32E-NEXT:    sw a1, 12(sp)
+; ILP32E-NEXT:    addi a0, sp, 19
+; ILP32E-NEXT:    andi a1, a0, -8
+; ILP32E-NEXT:    addi a0, a1, 8
+; ILP32E-NEXT:    sw a0, 0(sp)
+; ILP32E-NEXT:    lw a0, 0(a1)
+; ILP32E-NEXT:    lw a1, 4(a1)
+; ILP32E-NEXT:    lui a3, 262144
+; ILP32E-NEXT:    li a2, 0
+; ILP32E-NEXT:    call __eqdf2@plt
+; ILP32E-NEXT:    bnez a0, .LBB1_2
+; ILP32E-NEXT:  # %bb.1: # %if.end
+; ILP32E-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-NEXT:    addi sp, sp, 32
+; ILP32E-NEXT:    ret
+; ILP32E-NEXT:  .LBB1_2: # %if.then
+; ILP32E-NEXT:    call abort@plt
+;
+; ILP32E-WITHFP-LABEL: va_double:
+; ILP32E-WITHFP:       # %bb.0: # %entry
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -36
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 36
+; ILP32E-WITHFP-NEXT:    sw ra, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -28
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -32
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 12
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 24
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a1, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a0, a1, 8
+; ILP32E-WITHFP-NEXT:    sw a0, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a1)
+; ILP32E-WITHFP-NEXT:    lw a1, 4(a1)
+; ILP32E-WITHFP-NEXT:    lui a3, 262144
+; ILP32E-WITHFP-NEXT:    li a2, 0
+; ILP32E-WITHFP-NEXT:    call __eqdf2@plt
+; ILP32E-WITHFP-NEXT:    bnez a0, .LBB1_2
+; ILP32E-WITHFP-NEXT:  # %bb.1: # %if.end
+; ILP32E-WITHFP-NEXT:    lw ra, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 36
+; ILP32E-WITHFP-NEXT:    ret
+; ILP32E-WITHFP-NEXT:  .LBB1_2: # %if.then
+; ILP32E-WITHFP-NEXT:    call abort@plt
+entry:
+  %args = alloca i8*, align 4
+  %args1 = bitcast i8** %args to i8*
+  call void @llvm.va_start(i8* %args1)
+  %argp.cur = load i8*, i8** %args, align 4
+  %0 = ptrtoint i8* %argp.cur to i32
+  %1 = add i32 %0, 7
+  %2 = and i32 %1, -8
+  %argp.cur.aligned = inttoptr i32 %2 to i8*
+  %argp.next = getelementptr inbounds i8, i8* %argp.cur.aligned, i32 8
+  store i8* %argp.next, i8** %args, align 4
+  %3 = bitcast i8* %argp.cur.aligned to double*
+  %4 = load double, double* %3, align 8
+  %cmp = fcmp une double %4, 2.000000e+00
+  br i1 %cmp, label %if.then, label %if.end
+
+if.then:
+  call void @abort()
+  unreachable
+
+if.end:
+  %args2 = bitcast i8** %args to i8*
+  call void @llvm.va_end(i8* %args2)
+  ret void
+}
diff --git a/llvm/test/CodeGen/RISCV/vararg.ll b/llvm/test/CodeGen/RISCV/vararg.ll
index df8a6706997b..690aa04a4e69 100644
--- a/llvm/test/CodeGen/RISCV/vararg.ll
+++ b/llvm/test/CodeGen/RISCV/vararg.ll
@@ -11,6 +11,10 @@
 ; RUN: llc -mtriple=riscv32 -mattr=+d -target-abi ilp32d \
 ; RUN:     -verify-machineinstrs < %s \
 ; RUN:   | FileCheck -check-prefix=RV32D-ILP32-ILP32F-ILP32D-FPELIM %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-FPELIM %s
+; RUN: llc -mtriple=riscv32 -target-abi ilp32e -frame-pointer=all -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=ILP32E-WITHFP %s
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs < %s \
 ; RUN:   | FileCheck -check-prefix=LP64-LP64F-LP64D-FPELIM %s
 ; RUN: llc -mtriple=riscv64 -mattr=+d -target-abi lp64f \
@@ -21,6 +25,10 @@
 ; RUN:   | FileCheck -check-prefix=LP64-LP64F-LP64D-FPELIM %s
 ; RUN: llc -mtriple=riscv64 -verify-machineinstrs -frame-pointer=all < %s \
 ; RUN:   | FileCheck -check-prefix=LP64-LP64F-LP64D-WITHFP %s
+; RUN: llc -mtriple=riscv64 -target-abi lp64e -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=LP64E-FPELIM %s
+; RUN: llc -mtriple=riscv64 -target-abi lp64e -frame-pointer=all -verify-machineinstrs < %s \
+; RUN:   | FileCheck -check-prefix=LP64E-WITHFP %s
 
 ; The same vararg calling convention is used for ilp32/ilp32f/ilp32d and for
 ; lp64/lp64f/lp64d. Different CHECK lines are required for RV32D due to slight
@@ -97,6 +105,44 @@ define i32 @va1(ptr %fmt, ...) {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va1:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 32
+; ILP32E-FPELIM-NEXT:    mv a0, a1
+; ILP32E-FPELIM-NEXT:    sw a5, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 20(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 16(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    addi a1, sp, 16
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 48
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -28
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -32
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 24
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -202,6 +248,39 @@ define i32 @va1_va_arg(ptr %fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va1_va_arg:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    mv a0, a1
+; ILP32E-FPELIM-NEXT:    sw a5, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 20(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 16(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    addi a1, sp, 16
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1_va_arg:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1_va_arg:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -338,6 +417,62 @@ define i32 @va1_va_arg_alloca(ptr %fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va1_va_arg_alloca:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -40
+; ILP32E-FPELIM-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 16
+; ILP32E-FPELIM-NEXT:    mv s1, a1
+; ILP32E-FPELIM-NEXT:    sw a5, 20(s0)
+; ILP32E-FPELIM-NEXT:    sw a4, 16(s0)
+; ILP32E-FPELIM-NEXT:    sw a3, 12(s0)
+; ILP32E-FPELIM-NEXT:    sw a2, 8(s0)
+; ILP32E-FPELIM-NEXT:    sw a1, 4(s0)
+; ILP32E-FPELIM-NEXT:    addi a0, s0, 8
+; ILP32E-FPELIM-NEXT:    sw a0, -16(s0)
+; ILP32E-FPELIM-NEXT:    addi a0, a1, 3
+; ILP32E-FPELIM-NEXT:    andi a0, a0, -4
+; ILP32E-FPELIM-NEXT:    sub a0, sp, a0
+; ILP32E-FPELIM-NEXT:    mv sp, a0
+; ILP32E-FPELIM-NEXT:    call notdead@plt
+; ILP32E-FPELIM-NEXT:    mv a0, s1
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -16
+; ILP32E-FPELIM-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 40
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1_va_arg_alloca:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -40
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    mv s1, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a0, -16(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, a1, 3
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    sub a0, sp, a0
+; ILP32E-WITHFP-NEXT:    mv sp, a0
+; ILP32E-WITHFP-NEXT:    call notdead@plt
+; ILP32E-WITHFP-NEXT:    mv a0, s1
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -16
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 40
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1_va_arg_alloca:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -96
@@ -451,6 +586,33 @@ define void @va1_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 16
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va1_caller:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    lui a2, 261888
+; ILP32E-FPELIM-NEXT:    li a3, 2
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    call va1@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va1_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    lui a2, 261888
+; ILP32E-WITHFP-NEXT:    li a3, 2
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call va1@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va1_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -16
@@ -477,6 +639,33 @@ define void @va1_caller() nounwind {
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    addi sp, sp, 16
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ret
+;
+; LP64E-FPELIM-LABEL: va1_caller:
+; LP64E-FPELIM:       # %bb.0:
+; LP64E-FPELIM-NEXT:    addi sp, sp, -8
+; LP64E-FPELIM-NEXT:    sd ra, 0(sp) # 8-byte Folded Spill
+; LP64E-FPELIM-NEXT:    li a1, 1023
+; LP64E-FPELIM-NEXT:    slli a1, a1, 52
+; LP64E-FPELIM-NEXT:    li a2, 2
+; LP64E-FPELIM-NEXT:    call va1@plt
+; LP64E-FPELIM-NEXT:    ld ra, 0(sp) # 8-byte Folded Reload
+; LP64E-FPELIM-NEXT:    addi sp, sp, 8
+; LP64E-FPELIM-NEXT:    ret
+;
+; LP64E-WITHFP-LABEL: va1_caller:
+; LP64E-WITHFP:       # %bb.0:
+; LP64E-WITHFP-NEXT:    addi sp, sp, -16
+; LP64E-WITHFP-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    addi s0, sp, 16
+; LP64E-WITHFP-NEXT:    li a1, 1023
+; LP64E-WITHFP-NEXT:    slli a1, a1, 52
+; LP64E-WITHFP-NEXT:    li a2, 2
+; LP64E-WITHFP-NEXT:    call va1@plt
+; LP64E-WITHFP-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    addi sp, sp, 16
+; LP64E-WITHFP-NEXT:    ret
   %1 = call i32 (ptr, ...) @va1(ptr undef, double 1.0, i32 2)
   ret void
 }
@@ -547,6 +736,45 @@ define i64 @va2(ptr %fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va2:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    sw a5, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 20(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 16(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 19
+; ILP32E-FPELIM-NEXT:    andi a0, a0, -8
+; ILP32E-FPELIM-NEXT:    addi a1, sp, 27
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 4(a0)
+; ILP32E-FPELIM-NEXT:    lw a0, 0(a0)
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va2:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 19
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 4(a0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a0)
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va2:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -683,6 +911,49 @@ define i64 @va2_va_arg(ptr %fmt, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va2_va_arg:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    sw a5, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 20(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 16(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 19
+; ILP32E-FPELIM-NEXT:    andi a1, a0, -8
+; ILP32E-FPELIM-NEXT:    addi a0, a1, 4
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a0, 0(a1)
+; ILP32E-FPELIM-NEXT:    addi a2, a1, 8
+; ILP32E-FPELIM-NEXT:    sw a2, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 4(a1)
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va2_va_arg:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a1, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a0, a1, 4
+; ILP32E-WITHFP-NEXT:    sw a0, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a1)
+; ILP32E-WITHFP-NEXT:    addi a2, a1, 8
+; ILP32E-WITHFP-NEXT:    sw a2, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 4(a1)
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va2_va_arg:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -764,6 +1035,31 @@ define void @va2_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 16
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va2_caller:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    lui a2, 261888
+; ILP32E-FPELIM-NEXT:    li a1, 0
+; ILP32E-FPELIM-NEXT:    call va2@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va2_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    lui a2, 261888
+; ILP32E-WITHFP-NEXT:    li a1, 0
+; ILP32E-WITHFP-NEXT:    call va2@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va2_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -16
@@ -788,6 +1084,31 @@ define void @va2_caller() nounwind {
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    addi sp, sp, 16
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ret
+;
+; LP64E-FPELIM-LABEL: va2_caller:
+; LP64E-FPELIM:       # %bb.0:
+; LP64E-FPELIM-NEXT:    addi sp, sp, -8
+; LP64E-FPELIM-NEXT:    sd ra, 0(sp) # 8-byte Folded Spill
+; LP64E-FPELIM-NEXT:    li a1, 1023
+; LP64E-FPELIM-NEXT:    slli a1, a1, 52
+; LP64E-FPELIM-NEXT:    call va2@plt
+; LP64E-FPELIM-NEXT:    ld ra, 0(sp) # 8-byte Folded Reload
+; LP64E-FPELIM-NEXT:    addi sp, sp, 8
+; LP64E-FPELIM-NEXT:    ret
+;
+; LP64E-WITHFP-LABEL: va2_caller:
+; LP64E-WITHFP:       # %bb.0:
+; LP64E-WITHFP-NEXT:    addi sp, sp, -16
+; LP64E-WITHFP-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    addi s0, sp, 16
+; LP64E-WITHFP-NEXT:    li a1, 1023
+; LP64E-WITHFP-NEXT:    slli a1, a1, 52
+; LP64E-WITHFP-NEXT:    call va2@plt
+; LP64E-WITHFP-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    addi sp, sp, 16
+; LP64E-WITHFP-NEXT:    ret
  %1 = call i64 (ptr, ...) @va2(ptr undef, double 1.000000e+00)
  ret void
 }
@@ -864,6 +1185,49 @@ define i64 @va3(i32 %a, i64 %b, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 32
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va3:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    sw a5, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 20(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 27
+; ILP32E-FPELIM-NEXT:    andi a0, a0, -8
+; ILP32E-FPELIM-NEXT:    addi a3, sp, 35
+; ILP32E-FPELIM-NEXT:    sw a3, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a3, 4(a0)
+; ILP32E-FPELIM-NEXT:    lw a0, 0(a0)
+; ILP32E-FPELIM-NEXT:    add a2, a2, a3
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    sltu a1, a0, a1
+; ILP32E-FPELIM-NEXT:    add a1, a2, a1
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va3:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -32
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    sw a5, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a3, s0, 19
+; ILP32E-WITHFP-NEXT:    sw a3, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a3, 4(a0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a0)
+; ILP32E-WITHFP-NEXT:    add a2, a2, a3
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    sltu a1, a0, a1
+; ILP32E-WITHFP-NEXT:    add a1, a2, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 32
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va3:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -64
@@ -1007,6 +1371,53 @@ define i64 @va3_va_arg(i32 %a, i64 %b, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va3_va_arg:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    sw a5, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 20(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 27
+; ILP32E-FPELIM-NEXT:    andi a0, a0, -8
+; ILP32E-FPELIM-NEXT:    addi a3, a0, 4
+; ILP32E-FPELIM-NEXT:    sw a3, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a3, 0(a0)
+; ILP32E-FPELIM-NEXT:    addi a4, a0, 8
+; ILP32E-FPELIM-NEXT:    sw a4, 12(sp)
+; ILP32E-FPELIM-NEXT:    lw a4, 4(a0)
+; ILP32E-FPELIM-NEXT:    add a0, a1, a3
+; ILP32E-FPELIM-NEXT:    sltu a1, a0, a1
+; ILP32E-FPELIM-NEXT:    add a2, a2, a4
+; ILP32E-FPELIM-NEXT:    add a1, a2, a1
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va3_va_arg:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -32
+; ILP32E-WITHFP-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 16
+; ILP32E-WITHFP-NEXT:    sw a5, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 11
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -8
+; ILP32E-WITHFP-NEXT:    addi a3, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a3, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a3, 0(a0)
+; ILP32E-WITHFP-NEXT:    addi a4, a0, 8
+; ILP32E-WITHFP-NEXT:    sw a4, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw a4, 4(a0)
+; ILP32E-WITHFP-NEXT:    add a0, a1, a3
+; ILP32E-WITHFP-NEXT:    sltu a1, a0, a1
+; ILP32E-WITHFP-NEXT:    add a2, a2, a4
+; ILP32E-WITHFP-NEXT:    add a1, a2, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 32
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va3_va_arg:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -64
@@ -1096,6 +1507,37 @@ define void @va3_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 16
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va3_caller:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -4
+; ILP32E-FPELIM-NEXT:    sw ra, 0(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    li a0, 2
+; ILP32E-FPELIM-NEXT:    li a1, 1111
+; ILP32E-FPELIM-NEXT:    lui a4, 262144
+; ILP32E-FPELIM-NEXT:    li a2, 0
+; ILP32E-FPELIM-NEXT:    li a3, 0
+; ILP32E-FPELIM-NEXT:    call va3@plt
+; ILP32E-FPELIM-NEXT:    lw ra, 0(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 4
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va3_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -8
+; ILP32E-WITHFP-NEXT:    sw ra, 4(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 0(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 8
+; ILP32E-WITHFP-NEXT:    li a0, 2
+; ILP32E-WITHFP-NEXT:    li a1, 1111
+; ILP32E-WITHFP-NEXT:    lui a4, 262144
+; ILP32E-WITHFP-NEXT:    li a2, 0
+; ILP32E-WITHFP-NEXT:    li a3, 0
+; ILP32E-WITHFP-NEXT:    call va3@plt
+; ILP32E-WITHFP-NEXT:    lw ra, 4(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 0(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 8
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va3_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -16
@@ -1124,6 +1566,35 @@ define void @va3_caller() nounwind {
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    addi sp, sp, 16
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ret
+;
+; LP64E-FPELIM-LABEL: va3_caller:
+; LP64E-FPELIM:       # %bb.0:
+; LP64E-FPELIM-NEXT:    addi sp, sp, -8
+; LP64E-FPELIM-NEXT:    sd ra, 0(sp) # 8-byte Folded Spill
+; LP64E-FPELIM-NEXT:    li a2, 1
+; LP64E-FPELIM-NEXT:    slli a2, a2, 62
+; LP64E-FPELIM-NEXT:    li a0, 2
+; LP64E-FPELIM-NEXT:    li a1, 1111
+; LP64E-FPELIM-NEXT:    call va3@plt
+; LP64E-FPELIM-NEXT:    ld ra, 0(sp) # 8-byte Folded Reload
+; LP64E-FPELIM-NEXT:    addi sp, sp, 8
+; LP64E-FPELIM-NEXT:    ret
+;
+; LP64E-WITHFP-LABEL: va3_caller:
+; LP64E-WITHFP:       # %bb.0:
+; LP64E-WITHFP-NEXT:    addi sp, sp, -16
+; LP64E-WITHFP-NEXT:    sd ra, 8(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    sd s0, 0(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    addi s0, sp, 16
+; LP64E-WITHFP-NEXT:    li a2, 1
+; LP64E-WITHFP-NEXT:    slli a2, a2, 62
+; LP64E-WITHFP-NEXT:    li a0, 2
+; LP64E-WITHFP-NEXT:    li a1, 1111
+; LP64E-WITHFP-NEXT:    call va3@plt
+; LP64E-WITHFP-NEXT:    ld ra, 8(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    ld s0, 0(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    addi sp, sp, 16
+; LP64E-WITHFP-NEXT:    ret
  %1 = call i64 (i32, i64, ...) @va3(i32 2, i64 1111, double 2.000000e+00)
  ret void
 }
@@ -1257,6 +1728,87 @@ define i32 @va4_va_copy(i32 %argno, ...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va4_va_copy:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -40
+; ILP32E-FPELIM-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 8(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    mv s0, a1
+; ILP32E-FPELIM-NEXT:    sw a5, 36(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 32(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 20(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, sp, 24
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    call notdead@plt
+; ILP32E-FPELIM-NEXT:    lw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 3
+; ILP32E-FPELIM-NEXT:    andi a0, a0, -4
+; ILP32E-FPELIM-NEXT:    addi a1, a0, 4
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a1, 0(a0)
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 7
+; ILP32E-FPELIM-NEXT:    andi a0, a0, -4
+; ILP32E-FPELIM-NEXT:    addi a2, a0, 4
+; ILP32E-FPELIM-NEXT:    sw a2, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a2, 0(a0)
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 7
+; ILP32E-FPELIM-NEXT:    andi a0, a0, -4
+; ILP32E-FPELIM-NEXT:    addi a3, a0, 4
+; ILP32E-FPELIM-NEXT:    sw a3, 4(sp)
+; ILP32E-FPELIM-NEXT:    lw a0, 0(a0)
+; ILP32E-FPELIM-NEXT:    add a1, a1, s0
+; ILP32E-FPELIM-NEXT:    add a1, a1, a2
+; ILP32E-FPELIM-NEXT:    add a0, a1, a0
+; ILP32E-FPELIM-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 8(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 40
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va4_va_copy:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -44
+; ILP32E-WITHFP-NEXT:    sw ra, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 12(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s1, 8(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 20
+; ILP32E-WITHFP-NEXT:    mv s1, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, s0, 8
+; ILP32E-WITHFP-NEXT:    sw a0, -16(s0)
+; ILP32E-WITHFP-NEXT:    sw a0, -20(s0)
+; ILP32E-WITHFP-NEXT:    call notdead@plt
+; ILP32E-WITHFP-NEXT:    lw a0, -16(s0)
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 3
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    addi a1, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a1, -16(s0)
+; ILP32E-WITHFP-NEXT:    lw a1, 0(a0)
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 7
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    addi a2, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a2, -16(s0)
+; ILP32E-WITHFP-NEXT:    lw a2, 0(a0)
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 7
+; ILP32E-WITHFP-NEXT:    andi a0, a0, -4
+; ILP32E-WITHFP-NEXT:    addi a3, a0, 4
+; ILP32E-WITHFP-NEXT:    sw a3, -16(s0)
+; ILP32E-WITHFP-NEXT:    lw a0, 0(a0)
+; ILP32E-WITHFP-NEXT:    add a1, a1, s1
+; ILP32E-WITHFP-NEXT:    add a1, a1, a2
+; ILP32E-WITHFP-NEXT:    add a0, a1, a0
+; ILP32E-WITHFP-NEXT:    lw ra, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 12(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s1, 8(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 44
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va4_va_copy:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -96
@@ -1498,6 +2050,104 @@ define void @va5_aligned_stack_caller() nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 64
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va5_aligned_stack_caller:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -64
+; ILP32E-FPELIM-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-FPELIM-NEXT:    addi s0, sp, 64
+; ILP32E-FPELIM-NEXT:    andi sp, sp, -16
+; ILP32E-FPELIM-NEXT:    li a0, 17
+; ILP32E-FPELIM-NEXT:    sw a0, 24(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 16
+; ILP32E-FPELIM-NEXT:    sw a0, 20(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 15
+; ILP32E-FPELIM-NEXT:    sw a0, 16(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 262236
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 655
+; ILP32E-FPELIM-NEXT:    sw a0, 12(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 377487
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 1475
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 14
+; ILP32E-FPELIM-NEXT:    sw a0, 4(sp)
+; ILP32E-FPELIM-NEXT:    li a0, 4
+; ILP32E-FPELIM-NEXT:    sw a0, 0(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 262153
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 491
+; ILP32E-FPELIM-NEXT:    sw a0, 44(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 545260
+; ILP32E-FPELIM-NEXT:    addi a0, a0, -1967
+; ILP32E-FPELIM-NEXT:    sw a0, 40(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 964690
+; ILP32E-FPELIM-NEXT:    addi a0, a0, -328
+; ILP32E-FPELIM-NEXT:    sw a0, 36(sp)
+; ILP32E-FPELIM-NEXT:    lui a0, 335544
+; ILP32E-FPELIM-NEXT:    addi a6, a0, 1311
+; ILP32E-FPELIM-NEXT:    lui a0, 688509
+; ILP32E-FPELIM-NEXT:    addi a5, a0, -2048
+; ILP32E-FPELIM-NEXT:    li a0, 1
+; ILP32E-FPELIM-NEXT:    li a1, 11
+; ILP32E-FPELIM-NEXT:    addi a2, sp, 32
+; ILP32E-FPELIM-NEXT:    li a3, 12
+; ILP32E-FPELIM-NEXT:    li a4, 13
+; ILP32E-FPELIM-NEXT:    sw a6, 32(sp)
+; ILP32E-FPELIM-NEXT:    call va5_aligned_stack_callee@plt
+; ILP32E-FPELIM-NEXT:    addi sp, s0, -64
+; ILP32E-FPELIM-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 64
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va5_aligned_stack_caller:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -64
+; ILP32E-WITHFP-NEXT:    sw ra, 60(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 56(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 64
+; ILP32E-WITHFP-NEXT:    andi sp, sp, -16
+; ILP32E-WITHFP-NEXT:    li a0, 17
+; ILP32E-WITHFP-NEXT:    sw a0, 24(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 16
+; ILP32E-WITHFP-NEXT:    sw a0, 20(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 15
+; ILP32E-WITHFP-NEXT:    sw a0, 16(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262236
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 655
+; ILP32E-WITHFP-NEXT:    sw a0, 12(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 377487
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 1475
+; ILP32E-WITHFP-NEXT:    sw a0, 8(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 14
+; ILP32E-WITHFP-NEXT:    sw a0, 4(sp)
+; ILP32E-WITHFP-NEXT:    li a0, 4
+; ILP32E-WITHFP-NEXT:    sw a0, 0(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 262153
+; ILP32E-WITHFP-NEXT:    addi a0, a0, 491
+; ILP32E-WITHFP-NEXT:    sw a0, 44(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 545260
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -1967
+; ILP32E-WITHFP-NEXT:    sw a0, 40(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 964690
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -328
+; ILP32E-WITHFP-NEXT:    sw a0, 36(sp)
+; ILP32E-WITHFP-NEXT:    lui a0, 335544
+; ILP32E-WITHFP-NEXT:    addi a6, a0, 1311
+; ILP32E-WITHFP-NEXT:    lui a0, 688509
+; ILP32E-WITHFP-NEXT:    addi a5, a0, -2048
+; ILP32E-WITHFP-NEXT:    li a0, 1
+; ILP32E-WITHFP-NEXT:    li a1, 11
+; ILP32E-WITHFP-NEXT:    addi a2, sp, 32
+; ILP32E-WITHFP-NEXT:    li a3, 12
+; ILP32E-WITHFP-NEXT:    li a4, 13
+; ILP32E-WITHFP-NEXT:    sw a6, 32(sp)
+; ILP32E-WITHFP-NEXT:    call va5_aligned_stack_callee@plt
+; ILP32E-WITHFP-NEXT:    addi sp, s0, -64
+; ILP32E-WITHFP-NEXT:    lw ra, 60(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 56(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 64
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va5_aligned_stack_caller:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -48
@@ -1560,6 +2210,73 @@ define void @va5_aligned_stack_caller() nounwind {
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ld s0, 32(sp) # 8-byte Folded Reload
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    addi sp, sp, 48
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ret
+;
+; LP64E-FPELIM-LABEL: va5_aligned_stack_caller:
+; LP64E-FPELIM:       # %bb.0:
+; LP64E-FPELIM-NEXT:    addi sp, sp, -56
+; LP64E-FPELIM-NEXT:    sd ra, 48(sp) # 8-byte Folded Spill
+; LP64E-FPELIM-NEXT:    li a0, 17
+; LP64E-FPELIM-NEXT:    sd a0, 40(sp)
+; LP64E-FPELIM-NEXT:    li a0, 16
+; LP64E-FPELIM-NEXT:    lui a1, %hi(.LCPI11_0)
+; LP64E-FPELIM-NEXT:    ld a1, %lo(.LCPI11_0)(a1)
+; LP64E-FPELIM-NEXT:    sd a0, 32(sp)
+; LP64E-FPELIM-NEXT:    li a0, 15
+; LP64E-FPELIM-NEXT:    sd a0, 24(sp)
+; LP64E-FPELIM-NEXT:    sd a1, 16(sp)
+; LP64E-FPELIM-NEXT:    li a0, 14
+; LP64E-FPELIM-NEXT:    sd a0, 8(sp)
+; LP64E-FPELIM-NEXT:    lui a0, 2384
+; LP64E-FPELIM-NEXT:    addiw a0, a0, 761
+; LP64E-FPELIM-NEXT:    slli a6, a0, 11
+; LP64E-FPELIM-NEXT:    lui a0, %hi(.LCPI11_1)
+; LP64E-FPELIM-NEXT:    ld a2, %lo(.LCPI11_1)(a0)
+; LP64E-FPELIM-NEXT:    lui a0, %hi(.LCPI11_2)
+; LP64E-FPELIM-NEXT:    ld a3, %lo(.LCPI11_2)(a0)
+; LP64E-FPELIM-NEXT:    li a0, 1
+; LP64E-FPELIM-NEXT:    li a1, 11
+; LP64E-FPELIM-NEXT:    li a4, 12
+; LP64E-FPELIM-NEXT:    li a5, 13
+; LP64E-FPELIM-NEXT:    sd a6, 0(sp)
+; LP64E-FPELIM-NEXT:    call va5_aligned_stack_callee@plt
+; LP64E-FPELIM-NEXT:    ld ra, 48(sp) # 8-byte Folded Reload
+; LP64E-FPELIM-NEXT:    addi sp, sp, 56
+; LP64E-FPELIM-NEXT:    ret
+;
+; LP64E-WITHFP-LABEL: va5_aligned_stack_caller:
+; LP64E-WITHFP:       # %bb.0:
+; LP64E-WITHFP-NEXT:    addi sp, sp, -64
+; LP64E-WITHFP-NEXT:    sd ra, 56(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    sd s0, 48(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    addi s0, sp, 64
+; LP64E-WITHFP-NEXT:    li a0, 17
+; LP64E-WITHFP-NEXT:    sd a0, 40(sp)
+; LP64E-WITHFP-NEXT:    li a0, 16
+; LP64E-WITHFP-NEXT:    lui a1, %hi(.LCPI11_0)
+; LP64E-WITHFP-NEXT:    ld a1, %lo(.LCPI11_0)(a1)
+; LP64E-WITHFP-NEXT:    sd a0, 32(sp)
+; LP64E-WITHFP-NEXT:    li a0, 15
+; LP64E-WITHFP-NEXT:    sd a0, 24(sp)
+; LP64E-WITHFP-NEXT:    sd a1, 16(sp)
+; LP64E-WITHFP-NEXT:    li a0, 14
+; LP64E-WITHFP-NEXT:    sd a0, 8(sp)
+; LP64E-WITHFP-NEXT:    lui a0, 2384
+; LP64E-WITHFP-NEXT:    addiw a0, a0, 761
+; LP64E-WITHFP-NEXT:    slli a6, a0, 11
+; LP64E-WITHFP-NEXT:    lui a0, %hi(.LCPI11_1)
+; LP64E-WITHFP-NEXT:    ld a2, %lo(.LCPI11_1)(a0)
+; LP64E-WITHFP-NEXT:    lui a0, %hi(.LCPI11_2)
+; LP64E-WITHFP-NEXT:    ld a3, %lo(.LCPI11_2)(a0)
+; LP64E-WITHFP-NEXT:    li a0, 1
+; LP64E-WITHFP-NEXT:    li a1, 11
+; LP64E-WITHFP-NEXT:    li a4, 12
+; LP64E-WITHFP-NEXT:    li a5, 13
+; LP64E-WITHFP-NEXT:    sd a6, 0(sp)
+; LP64E-WITHFP-NEXT:    call va5_aligned_stack_callee@plt
+; LP64E-WITHFP-NEXT:    ld ra, 56(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    ld s0, 48(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    addi sp, sp, 64
+; LP64E-WITHFP-NEXT:    ret
   %1 = call i32 (i32, ...) @va5_aligned_stack_callee(i32 1, i32 11,
     fp128 0xLEB851EB851EB851F400091EB851EB851, i32 12, i32 13, i64 20000000000,
     i32 14, double 2.720000e+00, i32 15, [2 x i32] [i32 16, i32 17])
@@ -1624,6 +2341,39 @@ define i32 @va6_no_fixed_args(...) nounwind {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    addi sp, sp, 48
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va6_no_fixed_args:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    addi sp, sp, -32
+; ILP32E-FPELIM-NEXT:    sw a5, 28(sp)
+; ILP32E-FPELIM-NEXT:    sw a4, 24(sp)
+; ILP32E-FPELIM-NEXT:    sw a3, 20(sp)
+; ILP32E-FPELIM-NEXT:    sw a2, 16(sp)
+; ILP32E-FPELIM-NEXT:    sw a1, 12(sp)
+; ILP32E-FPELIM-NEXT:    sw a0, 8(sp)
+; ILP32E-FPELIM-NEXT:    addi a1, sp, 12
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    addi sp, sp, 32
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va6_no_fixed_args:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -48
+; ILP32E-WITHFP-NEXT:    sw ra, 20(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 16(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 24
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    sw a0, 0(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 4
+; ILP32E-WITHFP-NEXT:    sw a1, -12(s0)
+; ILP32E-WITHFP-NEXT:    lw ra, 20(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 16(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 48
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va6_no_fixed_args:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    addi sp, sp, -80
@@ -1777,6 +2527,68 @@ define i32 @va_large_stack(ptr %fmt, ...) {
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    add sp, sp, a1
 ; RV32D-ILP32-ILP32F-ILP32D-FPELIM-NEXT:    ret
 ;
+; ILP32E-FPELIM-LABEL: va_large_stack:
+; ILP32E-FPELIM:       # %bb.0:
+; ILP32E-FPELIM-NEXT:    lui a0, 24414
+; ILP32E-FPELIM-NEXT:    addi a0, a0, 288
+; ILP32E-FPELIM-NEXT:    sub sp, sp, a0
+; ILP32E-FPELIM-NEXT:    .cfi_def_cfa_offset 100000032
+; ILP32E-FPELIM-NEXT:    mv a0, a1
+; ILP32E-FPELIM-NEXT:    lui a6, 24414
+; ILP32E-FPELIM-NEXT:    add a6, sp, a6
+; ILP32E-FPELIM-NEXT:    sw a5, 284(a6)
+; ILP32E-FPELIM-NEXT:    lui a5, 24414
+; ILP32E-FPELIM-NEXT:    add a5, sp, a5
+; ILP32E-FPELIM-NEXT:    sw a4, 280(a5)
+; ILP32E-FPELIM-NEXT:    lui a4, 24414
+; ILP32E-FPELIM-NEXT:    add a4, sp, a4
+; ILP32E-FPELIM-NEXT:    sw a3, 276(a4)
+; ILP32E-FPELIM-NEXT:    lui a3, 24414
+; ILP32E-FPELIM-NEXT:    add a3, sp, a3
+; ILP32E-FPELIM-NEXT:    sw a2, 272(a3)
+; ILP32E-FPELIM-NEXT:    lui a2, 24414
+; ILP32E-FPELIM-NEXT:    add a2, sp, a2
+; ILP32E-FPELIM-NEXT:    sw a1, 268(a2)
+; ILP32E-FPELIM-NEXT:    lui a1, 24414
+; ILP32E-FPELIM-NEXT:    addi a1, a1, 272
+; ILP32E-FPELIM-NEXT:    add a1, sp, a1
+; ILP32E-FPELIM-NEXT:    sw a1, 4(sp)
+; ILP32E-FPELIM-NEXT:    lui a1, 24414
+; ILP32E-FPELIM-NEXT:    addi a1, a1, 288
+; ILP32E-FPELIM-NEXT:    add sp, sp, a1
+; ILP32E-FPELIM-NEXT:    ret
+;
+; ILP32E-WITHFP-LABEL: va_large_stack:
+; ILP32E-WITHFP:       # %bb.0:
+; ILP32E-WITHFP-NEXT:    addi sp, sp, -2044
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa_offset 2044
+; ILP32E-WITHFP-NEXT:    sw ra, 2016(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    sw s0, 2012(sp) # 4-byte Folded Spill
+; ILP32E-WITHFP-NEXT:    .cfi_offset ra, -28
+; ILP32E-WITHFP-NEXT:    .cfi_offset s0, -32
+; ILP32E-WITHFP-NEXT:    addi s0, sp, 2020
+; ILP32E-WITHFP-NEXT:    .cfi_def_cfa s0, 24
+; ILP32E-WITHFP-NEXT:    lui a0, 24414
+; ILP32E-WITHFP-NEXT:    addi a0, a0, -1740
+; ILP32E-WITHFP-NEXT:    sub sp, sp, a0
+; ILP32E-WITHFP-NEXT:    mv a0, a1
+; ILP32E-WITHFP-NEXT:    sw a5, 20(s0)
+; ILP32E-WITHFP-NEXT:    sw a4, 16(s0)
+; ILP32E-WITHFP-NEXT:    sw a3, 12(s0)
+; ILP32E-WITHFP-NEXT:    sw a2, 8(s0)
+; ILP32E-WITHFP-NEXT:    sw a1, 4(s0)
+; ILP32E-WITHFP-NEXT:    addi a1, s0, 8
+; ILP32E-WITHFP-NEXT:    lui a2, 24414
+; ILP32E-WITHFP-NEXT:    sub a2, s0, a2
+; ILP32E-WITHFP-NEXT:    sw a1, -272(a2)
+; ILP32E-WITHFP-NEXT:    lui a1, 24414
+; ILP32E-WITHFP-NEXT:    addi a1, a1, -1740
+; ILP32E-WITHFP-NEXT:    add sp, sp, a1
+; ILP32E-WITHFP-NEXT:    lw ra, 2016(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    lw s0, 2012(sp) # 4-byte Folded Reload
+; ILP32E-WITHFP-NEXT:    addi sp, sp, 2044
+; ILP32E-WITHFP-NEXT:    ret
+;
 ; LP64-LP64F-LP64D-FPELIM-LABEL: va_large_stack:
 ; LP64-LP64F-LP64D-FPELIM:       # %bb.0:
 ; LP64-LP64F-LP64D-FPELIM-NEXT:    lui a0, 24414
@@ -1848,6 +2660,70 @@ define i32 @va_large_stack(ptr %fmt, ...) {
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ld s0, 1952(sp) # 8-byte Folded Reload
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    addi sp, sp, 2032
 ; LP64-LP64F-LP64D-WITHFP-NEXT:    ret
+;
+; LP64E-FPELIM-LABEL: va_large_stack:
+; LP64E-FPELIM:       # %bb.0:
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    addiw a0, a0, 320
+; LP64E-FPELIM-NEXT:    sub sp, sp, a0
+; LP64E-FPELIM-NEXT:    .cfi_def_cfa_offset 100000064
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    add a0, sp, a0
+; LP64E-FPELIM-NEXT:    sd a1, 280(a0)
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    add a0, sp, a0
+; LP64E-FPELIM-NEXT:    sd a5, 312(a0)
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    add a0, sp, a0
+; LP64E-FPELIM-NEXT:    sd a4, 304(a0)
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    add a0, sp, a0
+; LP64E-FPELIM-NEXT:    sd a3, 296(a0)
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    add a0, sp, a0
+; LP64E-FPELIM-NEXT:    sd a2, 288(a0)
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    addiw a0, a0, 284
+; LP64E-FPELIM-NEXT:    add a0, sp, a0
+; LP64E-FPELIM-NEXT:    sd a0, 8(sp)
+; LP64E-FPELIM-NEXT:    lui a0, 24414
+; LP64E-FPELIM-NEXT:    add a0, sp, a0
+; LP64E-FPELIM-NEXT:    lw a0, 280(a0)
+; LP64E-FPELIM-NEXT:    lui a1, 24414
+; LP64E-FPELIM-NEXT:    addiw a1, a1, 320
+; LP64E-FPELIM-NEXT:    add sp, sp, a1
+; LP64E-FPELIM-NEXT:    ret
+;
+; LP64E-WITHFP-LABEL: va_large_stack:
+; LP64E-WITHFP:       # %bb.0:
+; LP64E-WITHFP-NEXT:    addi sp, sp, -2040
+; LP64E-WITHFP-NEXT:    .cfi_def_cfa_offset 2040
+; LP64E-WITHFP-NEXT:    sd ra, 1984(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    sd s0, 1976(sp) # 8-byte Folded Spill
+; LP64E-WITHFP-NEXT:    .cfi_offset ra, -56
+; LP64E-WITHFP-NEXT:    .cfi_offset s0, -64
+; LP64E-WITHFP-NEXT:    addi s0, sp, 1992
+; LP64E-WITHFP-NEXT:    .cfi_def_cfa s0, 48
+; LP64E-WITHFP-NEXT:    lui a0, 24414
+; LP64E-WITHFP-NEXT:    addiw a0, a0, -1704
+; LP64E-WITHFP-NEXT:    sub sp, sp, a0
+; LP64E-WITHFP-NEXT:    sd a1, 8(s0)
+; LP64E-WITHFP-NEXT:    sd a5, 40(s0)
+; LP64E-WITHFP-NEXT:    sd a4, 32(s0)
+; LP64E-WITHFP-NEXT:    sd a3, 24(s0)
+; LP64E-WITHFP-NEXT:    sd a2, 16(s0)
+; LP64E-WITHFP-NEXT:    addi a0, s0, 12
+; LP64E-WITHFP-NEXT:    lui a1, 24414
+; LP64E-WITHFP-NEXT:    sub a1, s0, a1
+; LP64E-WITHFP-NEXT:    sd a0, -288(a1)
+; LP64E-WITHFP-NEXT:    lw a0, 8(s0)
+; LP64E-WITHFP-NEXT:    lui a1, 24414
+; LP64E-WITHFP-NEXT:    addiw a1, a1, -1704
+; LP64E-WITHFP-NEXT:    add sp, sp, a1
+; LP64E-WITHFP-NEXT:    ld ra, 1984(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    ld s0, 1976(sp) # 8-byte Folded Reload
+; LP64E-WITHFP-NEXT:    addi sp, sp, 2040
+; LP64E-WITHFP-NEXT:    ret
   %large = alloca [ 100000000 x i8 ]
   %va = alloca ptr, align 4
   call void @llvm.va_start(ptr %va)
diff --git a/llvm/test/MC/RISCV/target-abi-invalid.s b/llvm/test/MC/RISCV/target-abi-invalid.s
index 20e9f89153e0..5b00a41d1fbc 100644
--- a/llvm/test/MC/RISCV/target-abi-invalid.s
+++ b/llvm/test/MC/RISCV/target-abi-invalid.s
@@ -30,7 +30,7 @@
 # RUN:   | FileCheck -check-prefix=RV32E-LP64 %s
 # RUN: llvm-mc -triple=riscv32 -mattr=+e,+f -target-abi lp64f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EF-LP64F %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi lp64f < %s 2>&1 \
+# RUN: not --crash llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi lp64f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EFD-LP64D %s
 
 # RV32I-LP64: 64-bit ABIs are not supported for 32-bit targets (ignoring target-abi)
@@ -66,14 +66,16 @@
 # RUN:   | FileCheck -check-prefix=RV32EF-ILP32F %s
 # RUN: llvm-mc -triple=riscv32 -mattr=+e,+f -target-abi ilp32f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EF-ILP32F %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32f < %s 2>&1 \
+# RUN: not --crash llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32f < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EFD-ILP32F %s
-# RUN: llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32d < %s 2>&1 \
+# RUN: not --crash llvm-mc -triple=riscv32 -mattr=+e,+d -target-abi ilp32d < %s 2>&1 \
 # RUN:   | FileCheck -check-prefix=RV32EFD-ILP32D %s
 
 # RV32E-ILP32: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
 # RV32EF-ILP32F: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
 # RV32EFD-ILP32F: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
+# RV32EFD-ILP32F: LLVM ERROR: ILP32E must not be used with the D ISA extension
 # RV32EFD-ILP32D: Only the ilp32e ABI is supported for RV32E (ignoring target-abi)
+# RV32EFD-ILP32D: LLVM ERROR: ILP32E must not be used with the D ISA extension
 
 nop
